<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta
      name="description"
      content="10 Fundamentos que todo desarrollador Front-End debe dominar"
    />
    <meta name="robots" content="index, follow" />
    <title>10 Fundamentos Front-End</title>
    <link rel="stylesheet" href="./css/estilos.css" />
    <link rel="stylesheet" href="./prism.css" />
    <link
      rel="icon"
      type="image/png"
      sizes="16x16"
      href="https://i.imgur.com/k4a0ecv.png"
    />
    <link rel="preconnect" href="https://fonts.gstatic.com" />
    <link
      href="https://fonts.googleapis.com/css2?family=PT+Serif:wght@400;700&family=Poppins:wght@200;300;400;700&display=swap"
      rel="stylesheet"
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Courier+Prime&display=swap"
      rel="stylesheet"
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Oxygen:wght@300;400;700&display=swap"
      rel="stylesheet"
    />
  </head>

  <body>
    <section class="construction">
      <p>
        <strong>En construcción</strong><br />Inicio: 09/01/2021 <br />
        Estreno-aprox: 15/02/2021 <br />
        % Avance:
      </p>
      <div class="capacidad_barra">
        <div class="capacidad_barra_full"></div>
      </div>
    </section>
    <header>
      <h1 class="blog-title">
        10 Fundamentos que todo desarrollador Front-End debe dominar
      </h1>
      <section class="blog-title__container">
        <p class="blog-title__description">
          En el mundo del desarrollo web, muchos profesionales han logrado
          destacar navegando por este vasto océano de tecnologías, lenguajes y
          frameworks. Aunque han tenido éxito, una parte considerable de
          desarrolladores aún percibe que gran parte de su trabajo funciona como
          <i>Arte de Magia</i>, lo cual desde una perspectiva
          <i>holística</i> de la <strong>Ingeniería de Software</strong> no es
          lo ideal.
        </p>
        <p class="blog-title__description">
          Dominar conceptos fundamentales como:
          <strong>"¿Cómo funciona realmente el motor de JavaScript?"</strong>,
          <strong>"¿Qué estructuras de datos utilizar y cuándo?"</strong> o
          <strong>"¿Cómo manejar el asincronismo en JavaScript?"</strong> puede
          marcar la diferencia entre un desarrollador competente y uno
          excepcional.
        </p>
        <p class="blog-title__description">
          En este artículo encontrarás fundamentos que quizás conoces
          superficialmente, pero es momento de profundizar. Te presento los
          <i>10 Fundamentos que todo desarrollador Front-End debe dominar.</i>
          <br />
        </p>
      </section>
    </header>

    <section class="topics-container topics-js">
      <ol class="numeracion-orden-principal">
        <li>
          <h2>
            <a
              class="topics-title topics-title--ready"
              href="javascript:void(0)"
            >
              Motores de JavaScript
            </a>
          </h2>
          <div class="topics-info">
            <p class="topics-copy">
              Como desarrolladores web, es bueno conocer los fundamentos del
              lenguaje Javascript y de su motor, este último con el fin de
              comprender como a partir de un lenguaje que los humanos podemos
              entender, se llega a convertir en algo que las maquinas pueden
              comprender y ejecutar.
            </p>
            <h3 class="topics-subtitle">Diferentes Motores de Javascript</h3>
            <p class="topics-copy">
              Cada navegador tiene su propio motor de javascript, entre los más
              conocidos tenemos los siguientes:
            </p>
            <figure>
              <img
                class="infografia"
                src="https://i.postimg.cc/7LZCgVn1/4to-post.png"
                alt="Infografía de los motores de Javascript"
              />
              <figcaption>
                Definición y distintos motores de JavaScript
              </figcaption>
            </figure>
            <p class="topics-copy">
              Revisaremos uno de los más utilizados, el V8 de Chrome:
            </p>
            <figure>
              <img
                class="infografia"
                src="https://i.postimg.cc/kgc66ZKX/4to-post-2.png"
                alt="Infografía de V8 Chrome Engine"
              />
              <figcaption>V8 Chrome Engine</figcaption>
            </figure>
            <p class="topics-copy">
              Pero ¿cómo funciona?, veamos todo el recorrido que hace nuestro
              código en Javascript desde nuestro editor de código hasta que
              sirve a su propósito.
            </p>
            <figure>
              <img
                class="infografia"
                src="https://i.postimg.cc/q7DNQ31P/4to-post-3.png"
                alt="Infografía de como funciona el motor V8 de Chrome"
              />
              <figcaption>Funcionamiento del motor V8 de Chrome</figcaption>
            </figure>
            <p class="topics-copy">
              Mostremos en código el bytecode y el machine code:
            </p>
            <figure>
              <img
                class="infografia"
                src="https://res.cloudinary.com/practicaldev/image/fetch/s--63gCOzJI--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://github.com/khaosdoctor/my-notes/raw/master/node/assets/ignition-bytecode.png"
                alt="Infografía de comparación de lenguajes de alto a bajo nivel: javascript - bytecode - machine code"
              />
              <figcaption>
                Javascript - Bytecode - Machine code
                <p>Fuente: Franziska Hinkelmann</p>
              </figcaption>
            </figure>
          </div>
        </li>

        <li>
          <h2>
            <a
              class="topics-title topics-title--ready"
              href="javascript:void(0)"
            >
              Scope & Closures
            </a>
          </h2>
          <div class="topics-info">
            <h3 class="topics-subtitle">Scope</h3>
            <p class="topics-copy">
              Es el contexto de ejecución, en el cual los valores y expresiones
              son visibles o pueden ser referenciados, scopes pueden ser
              colocados en jerarquía, así el hijo o scope interno (inner scope)
              tiene acceso al padre o scope externo (outer scope), pero no
              viceversa. Scope es definido en tiempo de parseo.
            </p>
            <h3 class="topics-subtitle">Ámbito Léxico / Lexical Scope</h3>
            <p class="topics-copy">
              Se basa en el lugar donde una variable fue declarada para
              determinar dónde esta variable estará disponible. Las funciones
              anidadas tienen acceso a las variables declaradas en su ámbito
              exterior.
            </p>
            <p class="topics-copy">
              Pasemos a ver unos ejemplos de scope, pero con la siguiente
              pregunta en mente:
              <strong>¿Cómo funciona realmente Javascript?</strong>
            </p>

            <pre>
            <code class="language-js">
              //Exercise 1
              let a = 3;
              function addTwo(x) {
                let ret = x + 2;
                return ret;
              }
              let b = addTwo(a);
              console.log(b);
              //5

              //The compiler asks the global scope manager(gsm) if already exists a variable named "a", the gsm doesn't find it, so it creates it. then assigns to it the aritmethic expression, a literal value of 3, after that the gsm has a new request for creating a variable named addTwo, as it doesn't exists yet, it's created and is assigned to it a function definition. Still in the global scope a b variable is also created and assign for now an undefined, in that line, occurs a call expression addTwo() the gsm check if it exits in that scope and there it is, so executes it sending an a argument, so a is also checked and its value is 3 in the global scope, so the addTwo function have a parameter x, so it's created in the local execution context, and it's assigned the value of 3, so x = 3; then a ret variable is created in the function execution context and it's assign to it a binary expression (x + 2), the x = 3 and 2; 5 is assigned to ret, the next line is a return statement and finish the function, the 5 is returned when it's called and immediately the function instance as well as its local execution context and its variables (x, ret) are destroyed by the garbage colector.
              //Then again in the global scope the b variable is assigned with the 5 returned. and finally it's put to the console the value of b (5).



              //Exercise 2
              //Here we can see the lexical scope definition in practice: 
              //Lexical scope is when a function can access a variable declared in its outer scope(next outer scope and so on)
              //Or when a variable defined outside a function can be accessible inside that function

              //Lexical scope / Ambito Léxico / Scope Chain
              let val1 = 2;
              function multiplyThis(n) {
                let ret = n * val1;
                return ret;
              }
              let multiplied = multiplyThis(6);
              console.log('example of scope:', multiplied);
              //example of scope: 12


              //Exercise 3
              //A function that returns a function example is essential to understand closures
              let val = 7;
              function createAdder() {
                function addNumbers(a, b) {
                  let ret = a + b;
                  return ret;
                }
                return addNumbers;
              }
              let adder = createAdder();
              let sum = adder(val, 8);
              console.log('example of function returning a function:', sum);
              //example of function returning a function: 15


              // Line 55: We declare a variable val in the global execution context and assign the value 7 to that variable

              // Line 56: We declare a variable named createAdder and we assign a function definition to it (we put "function" before createAdder) all this happens int the global exection context, we have to remember that whatever is between the curly brackets {} is not executed, not even evalated, just stored the function definition into a variable for future use

              // Line 63: we declare a new variable, named adder in the global execution context, temporarily, undefined is assigned to adder. , we see round brackets() so we need to execute or call the function. let's query the gec's memory and look for a variable named createrAdder, it was created  before so let's call it.

              // Line 56: a new local execution context is created.the engine adds the new context to the call MediaStreamTrack, the function has no arguments, so let's jump right into the body of it.

              // Line 57-60, we have a new function declaration, we create the variable addNumbers in the local execution context( addNumbers just exists in this lec) and assign a function definition to it (function addNumber) , we store the function definition in the local variable named addNumber.

              // Line 61: We return the content of the variable addNumbers. The engine looks for a variable named addNumbers and finds it. It's a function definition, it's ok because this function(addNumbers) can return anything, including another function definition, so it return addNumbers definition- anything between the brackets on lines 58 and 59 makes up the function definition, we also remove the local execution context from the call stack.

              // After return, the lec is destroyed , the addNumbers variable doesn't exist anymore. the function definition still exists though, it was returned from the createAdder function and assigned to the variable adder, which was previously created.

              // Now in line 64, we define a new sum variable in the gec/global scope, we assign undefined to it.

              // Then we need to execute a function, the function named adder, we look it up in the global scope/gec and we find it, this function takes two parameters 

              // Let's retrieve these parameteres, so we can call the function (with the correct arguments) and pass it, remember that the addNumbers function definition was assigned to adder because of that we call adder(2 parameters), in this case val was defined before and the second parameter is 8

              // Now we have to execute that function (adder), a new local execution context (local scope) is created. Within the lec two new variables are created: a and b. they were assigned the values 7 and 8, as the arguments we passed before

              //A new variable is declared, name ret, it's declared in the lec, its value is set to undefined. Then an adition is performed, where we add the content of variable a and b, the result (15) is assigned to the ret variable

              // After that ret is returned, the lec is destroyed , it is removed from the call stack, the variables a, b and ret no longer exist.

              // The returned value is assigned to the variable named sum

              // We print out the value of sum to the console.



              // Finally we'll see a closure:
              function createCounter() {
                let counter = 0;
                const myFunction = function() {
                  counter = counter + 1;
                  return counter;
                }
                return myFunction;
              }
              const increment = createCounter();
              const c1 = increment();
              const c2 = increment();
              const c3 = increment();
              console.log('example increment:', c1, c2, c3);
              //example increment: 1 2 3


              //Line 101: The compiler finds a formal variable declaration with a function definition attach to it, then asks the global scope manager if the creatCounter variable exists, but the gsm says doesn't find any, so the compiler produce code that at execution time ask to create a new variable called students in that scope bucket.

              // Everything inside the createCounter function (beetween the curly brackets) it's not going to be processed yet (but it was already parsed- to make the AST). In modern web browser this is known as lazy compiling, it's going to be compiled when it's executed(called/invocked)

              //Now we are going to shorten the explanation

              //Line 109: An increment variable is going to be created in the global scope and then assigned a createCounter(), the "()" means that we call that function, so we find that variable declared and defined at line 101, a new local execturion context is created (a function scope).

              //Line 102: a counter variable is created in the createCounter scope and we assign the 0 to it.

              //Line 103: a MyFunction variable is declared and has a function definition assign to it, WE ALSO CREATE A CLOSURE AND INCLUDE IT AS PART OF THE FUNCTION DEFINITION. THE CLOSURE CAONTAINES THE VARIABLES THAT ARE IN SCOPE, IN THEIS CASE THE VARIABLE counter.

              //Everything from line 104 to 105 is not proccesed yet.

              //Line 107: we have a return statement , and the variable MyFunction is returned, the local scope manager is asked if the myFunction variable already exists, and the answer is yes, so because it has a function definition attached to it, it will return  the function definition (whatever is from line 104 to 105) and its closure. The garbage collector takes care of the local scopes and local variables created until now. 

              //Next we assign line 104-105 to the increment variable; so now that function definition is not labeled myFunction anymore, now is called increment and has a function definition including its closure.

              //Line 110: a c1 variable is created in the global scope and is assigned a callingExpression increment(), Now we are going to execute line 104-105, so it is created a increment local scope when a counter variables is checked, before looking in the local and global scope, let's check the CLOSURE, it contains the variable named counter, and after the expression in line 104, its value is set to 1, now the closure contains counter with its value 1.

              //The counter value is returned (1) and it's assigned to c1

              //Line 111: We repeat steps in line 133, c2 gets assigned 2

              //Line 112: We repeat steps in line 133, c2 gets assigned 3.

              //Line 113: The content of variables c1, c2 and c3 is logged in console.

              //So now we understand how closures works, the key to remember is that when a function gets declared, it contains a function definition and a closure. The closure is a collection of all the variables in the function's scope.

              // This works even in the global scope, yes it is created a closure as well but since these functions were created in the global scope, they have access to all the variables in the global scope, and the closure concept is not that relevant


              //Another example with 2 functions returned (two closures), we'll see the same effect
              let glob = "g";
              function f1() {
                  let loc = "l";
                  glob = glob + loc;
                  function f2() {
                    let loc2 = "l2";
                    function f3() {
                        loc2 = loc2 + loc + glob;
                        return loc2;
                    }
                    return f3;
                  }
                  return f2;
              }
              const g1 = f1(); 
              const g2 = g1();
              const c1 = g2(); 
              const c2 = g2(); 
              console.log(c1); //l2lgl
              console.log(c2); //l2lgllgl



              //Bibliography:

              // Olivier De Meulder,"I never understood javascript closures.", Medium, https://medium.com/dailyjs/i-never-understood-javascript-closures-9663703368e8

              //Simpson, Kyle. You Don't Know JS Yet: Scope & Closures

              //MDN, Scope, https://developer.mozilla.org/en-US/docs/Glossary/Scope
            </code>
          </pre>

            <h3 class="topics-subtitle">Closures</h3>
            <p class="topics-copy">
              Como ya vimos en el ejemplo práctico lineas arriba, un closure es
              formado por una función y es la combinación de la definición de
              esta función, así como su ámbito léxico que comprenden las
              variables locales definidas en este scope.
            </p>
          </div>
        </li>

        <li>
          <h2>
            <a
              class="topics-title topics-title--ready"
              href="javascript:void(0)"
            >
              Asincronismo
            </a>
          </h2>
          <div class="topics-info">
            <h3 class="topics-subtitle">¿Qué es el Asincronismo?</h3>
            <p class="topics-copy">
              El asincronismo en JavaScript permite que el código se ejecute sin
              bloquear el hilo principal, permitiendo que múltiples operaciones
              se ejecuten concurrentemente. Esto es fundamental para crear
              aplicaciones web responsivas y eficientes.
            </p>

            <h4 class="topics-subtitle">Callbacks</h4>
            <p class="topics-copy">
              Los callbacks son funciones que se pasan como argumentos a otras
              funciones y se ejecutan en un momento posterior. Aunque son la
              base del asincronismo en JavaScript, pueden llevar al "Callback
              Hell" cuando se anidan múltiples operaciones asíncronas.
            </p>

            <h4 class="topics-subtitle">Promises</h4>
            <p class="topics-copy">
              Las Promises representan el resultado eventual de una operación
              asíncrona. Tienen tres estados: pending, fulfilled y rejected.
              Permiten un manejo más elegante del código asíncrono y evitan el
              anidamiento excesivo de callbacks.
            </p>

            <h4 class="topics-subtitle">Async/Await</h4>
            <p class="topics-copy">
              Async/await es una sintaxis más moderna y legible para trabajar
              con Promises. La palabra clave 'async' hace que una función
              retorne una Promise, mientras que 'await' pausa la ejecución hasta
              que la Promise se resuelve, haciendo que el código asíncrono se
              vea y comporte como código síncrono.
            </p>

            <h4 class="topics-subtitle">Event Loop</h4>
            <p class="topics-copy">
              El Event Loop es el mecanismo que permite que JavaScript maneje
              operaciones asíncronas. Monitorea la Call Stack y la Callback
              Queue, moviendo funciones de la cola al stack cuando este está
              vacío, permitiendo la ejecución no bloqueante de JavaScript.
            </p>
            <div>
              <img
                src="https://media2.dev.to/dynamic/image/width=1000,height=420,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fthepracticaldev.s3.amazonaws.com%2Fi%2Fek7ji4zrimozpp2yzk0a.png"
                alt="Event loop"
                style="width: 100%"
              />
            </div>
            <a
              href="https://dev.to/lydiahallie/javascript-visualized-event-loop-3dif"
              target="_blank"
              rel="noopener"
              >Source: JavaScript Visualized: Event Loop - Lydia Hallie</a
            >
          </div>
        </li>

        <li>
          <h2>
            <a
              class="topics-title topics-title--ready"
              href="javascript:void(0)"
            >
              Objetos
            </a>
          </h2>
          <div class="topics-info">
            <h3 class="topics-subtitle">¿Qué son los Objetos en JavaScript?</h3>
            <p class="topics-copy">
              Los objetos en JavaScript son colecciones de propiedades, donde
              cada propiedad es una asociación entre un nombre (clave) y un
              valor. Son fundamentales para organizar y estructurar datos de
              manera lógica, permitiendo crear representaciones de entidades del
              mundo real en código.
            </p>

            <h4 class="topics-subtitle">Creación de Objetos</h4>
            <p class="topics-copy">
              Existen múltiples formas de crear objetos en JavaScript:
            </p>
            <ul class="bullet-list">
              <li class="bullet">
                <strong>Object Literal:</strong> La forma más común y directa
              </li>
              <li class="bullet">
                <strong>Constructor Object():</strong> Usando la función
                constructora
              </li>
              <li class="bullet">
                <strong>Object.create():</strong> Creando con un prototipo
                específico
              </li>
              <li class="bullet">
                <strong>Factory Functions:</strong> Funciones que retornan
                objetos
              </li>
              <li class="bullet">
                <strong>Constructor Functions:</strong> Para crear múltiples
                instancias
              </li>
            </ul>

            <h4 class="topics-subtitle">Propiedades y Métodos</h4>
            <p class="topics-copy">
              Las propiedades pueden contener valores primitivos (string,
              number, boolean) o valores complejos (funciones, arrays, otros
              objetos). Cuando una propiedad contiene una función, se denomina
              método. Los métodos permiten que los objetos tengan
              comportamiento, no solo datos.
            </p>

            <h4 class="topics-subtitle">Acceso a Propiedades</h4>
            <p class="topics-copy">
              JavaScript ofrece dos formas principales de acceder a las
              propiedades:
            </p>
            <ul class="bullet-list">
              <li><strong>Dot Notation:</strong> objeto.propiedad</li>
              <li><strong>Bracket Notation:</strong> objeto['propiedad']</li>
            </ul>
            <p class="topics-copy">
              La bracket notation es especialmente útil cuando el nombre de la
              propiedad se almacena en una variable o contiene caracteres
              especiales.
            </p>

            <h4 class="topics-subtitle">Prototipos y Herencia</h4>
            <p class="topics-copy">
              JavaScript utiliza prototipos para implementar herencia. Cada
              objeto tiene una propiedad interna llamada [[Prototype]] que
              apunta a otro objeto. Cuando se accede a una propiedad que no
              existe en el objeto, JavaScript busca en la cadena de prototipos
              hasta encontrarla o llegar a null.
            </p>

            <h4 class="topics-subtitle">Métodos Útiles para Objetos</h4>
            <p class="topics-copy">
              JavaScript proporciona varios métodos estáticos para trabajar con
              objetos:
            </p>
            <ul class="bullet-list">
              <li>
                <strong>Object.keys():</strong> Retorna un array con las claves
                del objeto
              </li>
              <li>
                <strong>Object.values():</strong> Retorna un array con los
                valores del objeto
              </li>
              <li>
                <strong>Object.entries():</strong> Retorna un array de pares
                [clave, valor]
              </li>
              <li>
                <strong>Object.assign():</strong> Copia propiedades de un objeto
                a otro
              </li>
              <li>
                <strong>Object.freeze():</strong> Hace que un objeto sea
                inmutable
              </li>
              <li>
                <strong>Object.seal():</strong> Previene la adición de nuevas
                propiedades
              </li>
            </ul>

            <h4 class="topics-subtitle">Destructuring y Spread Operator</h4>
            <p class="topics-copy">
              Las características modernas de JavaScript facilitan el trabajo
              con objetos:
            </p>
            <ul class="bullet-list">
              <li>
                <strong>Destructuring:</strong> Extraer propiedades en variables
                individuales
              </li>
              <li>
                <strong>Spread Operator (...):</strong> Copiar y combinar
                objetos
              </li>
              <li>
                <strong>Rest Parameters:</strong> Capturar propiedades restantes
              </li>
            </ul>

            <h4 class="topics-subtitle">Mejores Prácticas</h4>
            <p class="topics-copy">Para trabajar eficientemente con objetos:</p>
            <ul class="bullet-list">
              <li>Usar nombres descriptivos para propiedades y métodos</li>
              <li>Evitar mutaciones innecesarias (preferir inmutabilidad)</li>
              <li>
                Utilizar Object.freeze() para objetos que no deben cambiar
              </li>
              <li>Aprovechar destructuring para código más limpio</li>
              <li>Considerar el uso de Map para claves dinámicas</li>
            </ul>
          </div>
        </li>

        <li>
          <h2>
            <a
              class="topics-title topics-title--ready"
              href="javascript:void(0)"
            >
              Estructuras de Datos
            </a>
          </h2>

          <div class="topics-info">
            Según Wikipedia una
            <a
              class="enlaces-externos"
              href="https://es.wikipedia.org/wiki/Estructura_de_datos"
              >estructura de datos</a
            >
            es una forma particular de organizar datos en una computadora para
            que puedan ser utilizados de manera eficiente. <br /><br />
            También podemos definirla como una forma de organizar datos.
            Comprenden colecciones de valores, las relaciones entre ellos y las
            funciones y operaciones que se les puedan aplicar. <br /><br />
            El uso "eficiente" que se le dará dependerá del motivo a necesitar
            cierta estructura de datos. Quizás necesitemos una estructura donde
            se requiere una búsqueda rápida de elementos, o una inserción
            eficiente, etc, todo dependerá de que aplicación estemos haciendo.
            <br /><br />
            Aquí entra un tema importante: la <strong>complejidad.</strong>
            <h3>La Complejidad</h3>
            Este término hace referencia a como se expresan las ventajas y
            desventajas que tiene cada estructura de datos al utilizarse en un
            problema en particular. La complejidad se puede expresar en 2 ejes:
            El
            <strong>espacio</strong> y el <strong>tiempo</strong>.
            <h4>El espacio</h4>
            La <strong>complejidad del espacio</strong> representa el consumo de
            memoria de una estructura de datos.
            <h4>El tiempo</h4>
            La <strong>complejidad del tiempo</strong> se necesita expresar para
            varias operaciones que se puede usar en estructuras de datos, tales
            como insertar(agregar), eliminar, buscar y/ o acceder elementos.
            <br />
            <figure>
              <img
                class="infografia"
                src="https://i.postimg.cc/1tBszKCD/GSVIDAL-WEB-6.png"
                alt="Infografía de tipos de estructuras de datos"
              />
              <figcaption>Principales tipos de Estructuras de Datos</figcaption>
            </figure>

            <br />
            Podemos agrupar estas estructuras en 3 diferentes tipos:
            <br /><br />
            <ol>
              <li class="elem-lista-numerada">
                Las estructuras del <i>tipo-Array</i>, como los
                <strong>Arrays</strong>, <strong>Stacks</strong> y
                <strong>Queues</strong> las cuales se diferencian principalmente
                en la forma de insertar y remover elementos de ellas.
              </li>
              <li class="elem-lista-numerada">
                Las <strong>Hash Tables</strong> dependen de
                <i>hash functions</i> para localizar y guardar información.
              </li>
              <li class="elem-lista-numerada">
                <strong>Linked Lists</strong>, <strong>Trees</strong> y
                <strong>Graphs</strong> son estructuras con <i>nodos</i> que
                guardan referencias con otros nodos.
              </li>
            </ol>

            ¿Quieres ver el código .js de todas estas estructuras de datos?.
            Puedes encontrarlo en GitHub en el repositorio
            <a
              class="enlaces-externos"
              href="https://github.com/gsvidal/DataStructures-JS/tree/master"
              target="_blank"
              rel="noopener"
              >Data Structures-JS</a
            >

            <h3 class="topics-subtitle">Arrays</h3>
            Los Arrays(arreglos) son una colección de elementos, los cuales son
            emparejados con un key(índice), la forma más básica de esta
            estructura es el array lineal(array unidimensional).
            <br /><br />
            Los arrays son una de las estructuras más antiguas e importantes,
            así como de las más utilizadas en casi toda aplicación.
            <br /><br />
            Creo que todos hemos utilizado un array en JavaScript, tan solo
            inicializándolo así:

            <pre>
            <code class="language-js">
var array1 = [1,3,4,5,7];
            </code>
          </pre>

            Pero ya que estamos en el fundamento de: <i>Estructura de Datos</i>,
            vamos a crear una clase MyArray y en ella, crear métodos para
            buscar, agregar, remover valores del array. En pocas palabras
            veremos como crear desde cero métodos similares a los
            <i>built-in methods</i> .push(), .pop(), unshift(), .shift(), etc.
            <br />
            <pre>
            <code class="language-js">
 class MyArray { 
   constructor() {
     this.length = 0;
     this.data = {};
   }
 }              
            </code>
          </pre>

            Luego instanciaremos la clase MyArray:
            <br />
            <pre>

          <code class="language-js">
myArray = new MyArray();
          </code>
          </pre>

            *Podemos utilizar el Inspector de elementos para trabajar esto, lo
            que nos da el siguiente output:
            <pre>
            <code class="language-js">
              <output>
//MyArray {length: 0, data: {…}}
              </output>
            </code>
          </pre>
            Como vemos esa estructura está vacía, tiene un lenght de 0 y no
            contiene data. <br /><br />
            Ahora creemos unos cuantos <strong>métodos</strong> para poder hacer
            operaciones sobre nuestro array. Los crearemos dentro de nuestra
            clase MyArray, previamente creada:<br />

            <pre>
            <code class="language-js">

 class MyArray {
   constructor() {
     this.length = 0;
     this.data = {};
   }
   //Nuestro método get devuelve el valor del elemento con índice index
   get(index) {
     return this.data[index];
   }
   //Nuestro método push añade un valor al final del array
   push(item) {
     this.data[this.length] = item;
     this.length++;
     return this.data;
   }
   //Nuestro método pop remueve el último elemento del array
   pop() {
     const lastItem = this.data[this.length - 1];
     delete this.data[this.length -1];
     this.length--;
   }
   //Nuestro método delete elimina el elemento de indice index y devuelve el elemento removido.
   delete(index) {
     const item = this.data[index];
     this.shiftIndex(index);
     return item;
   }
   shiftIndex(index) {
     for(let i = index; i < this.length - 1; i++) {
       this.data[i] = this.data[i + 1];
     }
     delete this.data[this.length - 1];
     this.length--;
   }
   //Nuestro método unshiftItem añade un elemento(item) al inicio de nuestro array y devuelve la longitud del array
   unshiftItem(item) {
     this.length++;
     this.unshiftIndex();
     this.data[0] = item;
     
     return this.length;
   }
   unshiftIndex() {
     for(let i = this.length - 1; i > 0 ; i--) {
       this.data[i] = this.data[i-1];
     }
   }
   //Para nuestro método shiftItem vamos a remover el primer elemento de nuestro array, usaremos el método delete() creado anteriormente.
   shiftItem() {
     return this.delete(0);
   }
 }
              </code>
          </pre>

            <h3 class="topics-subtitle">Stacks</h3>

            Los <strong>stacks</strong>(pilas) son también una colección de
            elementos, están apilados y cuenta con 3 operaciones principales,
            peek(), push() y pop(), la forma en que se añaden y remueven
            elementos es a través del ordenamiento LIFO(Last in, first out), es
            decir el último que entra es el primero que sale. Un ejemplo
            práctico y conocido de un stack es el call stack.
            <figure>
              <img
                class="infografia infografia-chica"
                src="https://i.postimg.cc/sfWVc0PQ/GSVIDAL-WEB-14.jpg.jpg"
                alt="Imagen de un stack"
              />
              <figcaption>Diagrama de un stack</figcaption>
            </figure>
            Ahora pasemos a lo interesante, crearemos un stack usando clases
            como en el caso del array. <br />
            Pero antes de eso expliquemos el concepto de <i>nodos</i>, que
            utilizaremos a lo largo del tema de estructura de datos, y si bien
            mencionamos que los Linked Lists, Trees y Graphs son estructuras
            basadas en nodos, también podemos tratar a cada elemento del stack(y
            más adelante al queue), como un nodo que tiene un valor(value) y que
            tiene una referencia a través de un puntero al siguiente elemento(el
            próximo en entrar).

            <pre>
            <code class="language-js">
 //Creamos una clase Node(nodo) para no repetir código en los métodos
 class Node {
   constructor(value) {
     this.value = value;
     this.next = null;
   }
 }

class Stack {
  constructor() {
    this.top = null;
    this.bottom = null;
    this.length = 0;
  }
  //Nuestro método peek nos devuelve el elemento top(último en ingresar)
  peek() {
    return this.top;
  }
  //Nuestro método push agrega un elemento al (top) del stack y nos devuelve el stack
  push(value) {
    const newNode = new Node(value);
    if(this.length === 0) {
      this.top = newNode;
      this.bottom = this.top;
    } else {
      const holdingPointer = newNode;
      this.top.next = holdingPointer;
      this.top = holdingPointer;
    }
    this.length++;

    return this;
  }
  //Nuestro método pop remueve el elemento top y nos devuelve el stack
  pop() {
    var penultimo = myStack.bottom;
    for(let i = 0; i < this.length-2; i++) {
      penultimo = penultimo.next;
    }

    this.top = penultimo;
    this.top.next = null;
    this.length--;

    return this;
  }
}
//Instanciamos la clase Stack
const myStack = new Stack();
            </code>
          </pre>

            <h3 class="topics-subtitle">Queues</h3>

            Los <strong>queues</strong> son <i>colas</i>, sus operaciones
            principales son agregar elementos al final de la cola(enqueue) y
            remover el primer elemento de la cola (dequeue), usa el protocolo
            FIFO (First in First Out), lo que significa que el primero que entra
            a la cola, es el primero que sale al remover un elemento.
            <figure>
              <img
                class="infografia infografia-chica"
                src="https://i.postimg.cc/SxkNj7MX/GSVIDAL-WEB-15.jpg"
                alt="Imagen de un queue"
              />
              <figcaption>Diagrama de un Queue</figcaption>
            </figure>
            Veamos el código:
            <pre>
            <code class="language-js">
//Creamos una clase Node(nodo) para no repetir código en los métodos
class Node {
  constructor(value) {
    this.value = value;
    this.next = null;
  }
}

class Queue {
  constructor() {
    this.first = null;
    this.last = null;
    this.length = 0;
  }
  //Nuestro método peek nos devuelve el elemento first(primero en la cola)
  peek() {
    return this.first;
  }
  //Con nuestro método enqueue agregaremos un elemento al final de la cola (last)
  enqueue(value) {
    const newNode = new Node(value);
    if(this.length === 0) {
      this.first = newNode;
      this.last = newNode;
    } else {
      this.last.next = newNode;
      this.last = newNode;
    }
    this.length++;

    return this;
  }
  //Con nuestro método dequeue removeremos el primer elemento de la cola
  dequeue() {
    if(this.length !== 0) {
    const second = myQueue.first.next;
    this.first = second;
    this.length--;

    return this;
    } else {
      console.log("Queue is empty, you cannot dequeue!")
    }
  }
  
}
//Instanciamos la clase Queue
const myQueue = new Queue();

            </code>
          </pre>

            <h3 class="topics-subtitle">Hash Tables</h3>

            Un <strong>Hash Table</strong> es una estructura de datos usada para
            implementar un array asociativo, donde se puede emparejar
            <i>keys</i> y <i>values</i>. Es similar a un objeto de JavaScript,
            con la diferencia que la hash table tiene un
            <strong>Hash Function</strong> que determina en que lugar de la
            memoria se ubicarán estos datos. Esta Hash Function recibe como
            argumento al key y retorna la dirección(address) de la locación en
            donde estará esta información. Pueden existir <i>colisiones</i>, lo
            que significa que puede haber dos keys diferentes para un mismo
            address, pero con el método set que veremos más adelante al enviar
            como parámetro al key, nos devolverá su value respectivo.
            <figure>
              <img
                class="infografia"
                src="https://i.postimg.cc/k4K8ygYB/GSVIDAL-WEB-13.jpg"
                alt="Imagen de un hash table"
              />
              <figcaption>Diagrama de Hash Table</figcaption>
            </figure>

            <pre>
            <code class="language-js">
 class HashTable {
   constructor(size) {
     this.data = new Array(size);
   }
   //Lo siguiente es un Hash Function que fue creado arbitrariamente,existen muchos Hash Functions en GitHub
   hashMethod(key) {
    let hash = 0;
    for (let i = 0; i < key.length; i++) {
      hash = (hash + key.charCodeAt(i) * i) % this.data.length;
    }
    return hash;
   }
   //El metodo set nos inserta un elemento con su key y value(puede haber colisiones)
   set(key, value) {
    const address = this.hashMethod(key);
    if (!this.data[address]) {
      this.data[address] = [];
    }
    this.data[address].push([key, value]);
    return this.data;
   }
   //El metodo get nos devuelve el valor que le corresponde al key, en caso no exista el key enviado nos devolverá undefined
   get(key) {
    const address = this.hashMethod(key);
    const currentBucket = this.data[address];
    if (currentBucket) {
      for (let i = 0; i < currentBucket.length; i++) {
        if (currentBucket[i][0] === key) {
          return currentBucket[i][1];
        }
      }
    }
    return undefined;
   }
 }     
 //Instanciamos el HashTable con 50 espacios libres
 const myHashTable = new HashTable(50);  

            </code>
          </pre>

            <h3 class="topics-subtitle">Linked Lists</h3>

            Los <strong>Linked Lists</strong> almacenan data en forma
            secuencial, pero en lugar de mantener índices, mantienen
            <i>pointers(punteros)</i> a otros elementos. El primer nodo es
            llamado <strong>head</strong> y el último nodo
            <strong>tail</strong>. <br /><br />
            Existen dos tipos de linked list:
            <ol>
              <li>
                <strong>Singly Linked List:</strong> <br />
                Cada nodo tiene solo un puntero hacia el siguiente nodo
                <i>(next)</i>.
              </li>
              <li>
                <strong>Doubly Linked List:</strong> <br />
                En este caso además del <i>next</i>, cada nodo tiene un puntero
                adicional hacia el nodo previo(prev).
              </li>
            </ol>
            <br />
            <figure class="infografias-container">
              <div>
                <img
                  class="infografias"
                  src="https://i.postimg.cc/GhBvqR7P/GSVIDAL-WEB-16.jpg"
                  alt="Imagen de Singly Linked List"
                />
                <figcaption>Diagrama de un Singly Linked List</figcaption>
              </div>
              <div>
                <img
                  class="infografias"
                  src="https://i.postimg.cc/R0TtNZhm/GSVIDAL-WEB-17.jpg"
                  alt="Imagen de Doubly Linked List"
                />
                <figcaption>Diagrama de un Doubly Linked List</figcaption>
              </div>
            </figure>
            Démosle un vistazo al código: <br />
            <strong>Singly Linked List:</strong>
            <pre>
            <code class="language-js">
//Creamos una clase Node(nodo) para no repetir código en los métodos
 class Node {
   constructor(value) {
     this.value = value;
     this.next = null;
   }
 }
 
 class MySinglyLinkedList {
   constructor(value) {
     this.head = {
       value: value,
       next: null
     }
     this.tail = this.head;
     this.length = 1;
   }
   //Nuestro método append agregará un elemento al final(tail) del Singly Linked List
   append(value) {
     const newNode = new Node(value);
     this.tail.next = newNode;
     this.tail = newNode;
     this.length++;
 
     return this;
   }
   //Nuestro método prepend agregará un elemento al inicio(head) del Singly Linked List
   prepend(value) {
     const newNode = new Node(value);
     newNode.next = this.head;
     this.head = newNode;
 
     this.length++;
   }
   //Nuestro método insert insertará un elemento con índice index en el Singly Linked List
   insert(index, value) {
     if(index >= this.length) {
       console.log("No hay suficientes elementos, será enviado al final");
       return this.append(value);
     }
 
     const newNode = new Node(value); 
     const firstPointer = this.getTheIndex(index - 1);
     //Se crea una const holdingPointer que servirá para no perder el puntero next del firstPointer.
     const holdingPointer = firstPointer.next;
     firstPointer.next = newNode;
     newNode.next = holdingPointer;
 
     this.length++;
 
     return this;
   }
 
   getTheIndex(index) {
     let currentNode = this.head;
 
     for(let counter = 0; counter < this.length; counter++) {
       if(counter !== index) {
         currentNode = currentNode.next;
       } else{
         return currentNode;
       }
     }
   }
 }
 //Instanciando MySinglyLinkedList:
 let myLinkedList = new MySinglyLinkedList(1;              
            </code>
          </pre>

            <strong>Doubly Linked List:</strong>
            <pre>
            <code class="language-js">
//Como podremos ver el código para el doubly linked list solo se diferencia por ser unas cuantas líneas más larga:

class Node {
  constructor(value) {
    this.value = value;
    this.next = null;
    this.prev = null;
  }
}
 
class MyDoublyLinkedList {
  constructor(value) {
    this.head = {
      value: value,
      next: null,
      // Doubly: se añade la siguiente linea
      prev: null,
    };
    this.tail = this.head;
 
    this.length = 1;
  }
  append(value) {
    const newNode = new Node(value);
    newNode.prev = this.tail;
    this.tail.next = newNode;
    this.tail = newNode;
    this.length++;
 
    return this;
  }
  prepend(value) {
    const newNode = new Node(value);
    // Doubly: se añade la siguiente linea
    this.head.prev = newNode;
    
    newNode.next = this.head;
    this.head = newNode;
 
    this.length++;
  }
  insert(index, value) {
    if(index >= this.length) {
      console.log("No hay suficientes elementos, será enviado al final");
      return this.append(value);
    }
 
    const newNode = new Node(value);
    let firstPointer = this.getTheIndex(index - 1);
    let secondPointer = this.getTheIndex(index);
    let holdingPointer = firstPointer.next;
    firstPointer.next = newNode;
    newNode.next = holdingPointer;
    // Doubly: se añaden las siguientes 3 líneas
    holdingPointer.prev = newNode;
    firstPointer = newNode.prev;
    holdingPointer = secondPointer;
 
    this.length++;
 
    return this;
 
  }
 
  getTheIndex(index) {
    
    let currentNode = this.head;
 
    for(let counter = 0; counter < this.length; counter++) {
      if(counter !== index) {
        currentNode = currentNode.next;
      } else{
        return currentNode;
      }
    }
  }
  
}
//Instanciando MyDoublyLinkedList:
let myDoublyLinkedList = new MyDoublyLinkedList(1);              
            </code>
          </pre>

            <h3 class="topics-subtitle">Trees</h3>

            Una estructura de datos en forma de árbol o
            <strong>Tree</strong> simula una estructura de árbol jerárquica, con
            un nodo padre, un valor root e hijos(children). Cada nodo contiene
            un valor y una referencia a su(s) hijo(s). <br /><br />
            En este caso veremos un Binary Search Tree, un tipo de Tree usado
            para insertar y buscar valores en la estructura. Un Binary Searh
            Tree consta de un root donde a partir de este elemento se inicia la
            búsqueda, cada elemento solo puede tener dos
            descendientes(children), los <i>children</i> que son mayores que el
            elemento padre se colocan debajo del padre pero al lado derecho y
            los menores al lado izquierdo. <br /><br />

            <figure class="infografias-container">
              <div>
                <img
                  class="infografias"
                  src="https://i.postimg.cc/ZKk8gb16/GSVIDAL-WEB-18.jpg"
                  alt="Imagen de un Tree"
                />
                <figcaption>Diagrama de un Tree</figcaption>
              </div>
              <div>
                <img
                  class="infografias"
                  src="https://i.postimg.cc/598YXwRF/GSVIDAL-WEB-19.jpg"
                  alt="Imagen de un Binary Search Tree"
                />
                <figcaption>Diagrama de un Binary Search Tree</figcaption>
              </div>
            </figure>

            Ahora sí, para este código, armaremos el binary search tree de
            arriba.

            <pre>
             <code class="language-js">         
  class Node {
    constructor(value) {
      this.left = null;
      this.right = null;
      this.value = value;
    }
  }
  
  class BinarySearchTree {
    constructor() {
      this.root = null;
    }
    //Con este método insert, podremos agregar nodos con sus valores y referencias según la condición si son menor o mayor al padre.
    insert(value) {
      const newNode = new Node(value);
      if(this.root === null) {
        this.root = newNode;
      } else {
        let currentNode = this.root;
        while(true) {
          if(value < currentNode.value) {
            if(!currentNode.left) {
              currentNode.left = newNode;
              return this;
            }
            currentNode = currentNode.left;
          } else {
            if(!currentNode.right) {
              currentNode.right = newNode;
              return this;
            }
            currentNode = currentNode.right;
          }
        } 
      }
    }
    //El método search nos permitirá devolver el nodo en el que se encuentra el valor(value) enviado como argumento. Recordar que el nodo es el conjunto de información como: value, left child, right child. En caso de recorrerse el binary search tree y no encontrar el valor buscado nos indicará que no existe el valor.
    search(value) {
      var msj = "no se encuentra el valor";
      if(this.root === null) {
        console.log(`The tree is empty!`);
      } else {
        let currentNode = this.root;
         while(true) {
          if(value === currentNode.value) {
            return currentNode;
          } else {
            if(value < currentNode.value) {
              if(currentNode.left) {
                currentNode = currentNode.left;
              } else {
                return msj;
              }
            } else {
              if(currentNode.right) {
                currentNode = currentNode.right;
              } else {
                return msj;
              }
            }
          }
          
         }
        } 
    }   
  }
  //Instanciamos BinarySearchTree
  const myBinarySearchTree = new BinarySearchTree();
             </code>
           </pre>

            <h3 class="topics-subtitle">Graphs</h3>

            Los grafos o <strong>Graphs</strong> consisten en una colección
            finita de vertices(nodos) unidos por bordes(edges), existen varios
            tipos de grafos, según diferentes criterios: <br /><br />
            <figure class="infografias-container">
              <div>
                <img
                  class="infografias"
                  id="infografias-graph"
                  src="https://i.postimg.cc/x1vCj6wq/GSVIDAL-WEB-20.jpg"
                  alt="Diagrama de un Graph"
                />
                <figcaption>Diagrama de un Graph</figcaption>
              </div>
              <div>
                <img
                  class="infografias"
                  src="https://i.postimg.cc/xCLrSZJ1/GSVIDAL-WEB-21.jpg"
                  alt="Tipos de Graph: Ponderado y no ponderado"
                />
                <figcaption>
                  Tipos de Graph: Ponderado y no ponderado
                </figcaption>
              </div>
            </figure>
            <figure class="infografias-container">
              <div>
                <img
                  class="infografias"
                  src="https://i.postimg.cc/gjfmM2Kj/GSVIDAL-WEB-24.jpg"
                  alt="Tipos de Graph: Cíclico y acíclico"
                />
                <figcaption>Tipos de Graph: Cíclico y acíclico</figcaption>
              </div>
              <div>
                <img
                  class="infografias"
                  src="https://i.postimg.cc/52DkN3MY/GSVIDAL-WEB-23.jpg"
                  alt="Tipos de Graph: Dirigido y no dirigido"
                />
                <figcaption>Tipos de Graph: Dirigido y no dirigido</figcaption>
              </div>
            </figure>
            Existen varias maneras de representar un grafo, pero 2 de las
            principales son: <br /><br />
            <ol>
              <li>
                <strong>Lista de Adyacencia:</strong> <br />
                Para cada vértice, se almacena una lista de vértices adyacentes.
              </li>
              <li>
                <strong>Matriz de Adyacencia:</strong> <br />
                La información es almacenada en una matriz bidimensional, en la
                cual las filas representan los vértices y las columnas
                representan los vértices a donde apuntan, la información en los
                bordes y vértices deben almacenarse externamente.
                <br /><br />
              </li>
            </ol>

            Para el código usaremos la representación con lista adjacente, del
            tipo no dirigido, y usaremos la forma y nodos del grafo de la
            imagen:
            <a class="enlaces-externos" href="#infografias-graph"
              >Diagrama de un Graph.</a
            >

            <pre>
             <code class="language-js">
 class Graph {
   constructor() {
     this.nodes = 0;
     this.adjacentList = {};
   }
   //Se agregan nodos(vértices)
   addVertex(node) {
     this.adjacentList[node] = [];
     this.nodes++;
   }
   //Se agregan bordes(edges) pasando como argumentos a nodos(nodo1 y nodo2), el grafo del ejercicio es del tipo no dirigido, así que debe colocarse el método push en ambas direcciones.
   addEdge(node1, node2) {
     this.adjacentList[node1].push(node2);
     this.adjacentList[node2].push(node1);
   }
 }
 
 const myGraph = new Graph();
 
 //Creamos los vértices(nodos):
 myGraph.addVertex(1);
 myGraph.addVertex(3);
 myGraph.addVertex(4);
 myGraph.addVertex(5);
 myGraph.addVertex(6);
 myGraph.addVertex(8);
 
 //Creamos los Edges(bordes), ya que hay 7 bordes en el gráfico, deben haber 7 addEdge:
 myGraph.addEdge(8,4);
 myGraph.addEdge(4,5);
 myGraph.addEdge(4,1);
 myGraph.addEdge(1,6);
 myGraph.addEdge(3,6);
 myGraph.addEdge(1,3);
 myGraph.addEdge(5,3);   
             </code>
           </pre>

            Comparemos el output luego de ingresar el código: <br /><br />
            <figure class="infografias-container">
              <div>
                <img
                  class="infografias"
                  id="infografias-graph"
                  src="https://i.postimg.cc/x1vCj6wq/GSVIDAL-WEB-20.jpg"
                  alt="Grafo a construir"
                />
                <figcaption>Grafo a construir</figcaption>
              </div>
              <div>
                <img
                  class="infografias"
                  src="https://i.postimg.cc/cHPPF9w0/myGraph.jpg"
                  alt="Output en Inspector de Elementos-Consola"
                />
                <figcaption>
                  Output en el Inspector de Elementos-Consola
                </figcaption>
              </div>
            </figure>

            Como vemos en el output, al llamar a <i>myGraph</i> en su
            adjacentList nos muestra los nodos y sus respectivos nodos unidos
            por bordes, por ejemplo el nodo 1 tiene como nodos adyacentes(unidos
            por un borde) a los nodos 4,6 y 3. Lo cual es rápidamente
            verificable viendo el diagrama del grafo <br /><br />

            <h3>Conclusiones</h3>

            Existen muchas más estructuras de datos las cuales responden de una
            mejor o no tan eficiente manera al uso que se les quiera dar,
            algunas resaltan por su eficiencia en tiempo de búsqueda, otras por
            la forma de insertar o remover elementos, aquí entra en juego la
            habilidad y experiencia del desarrollador/ingeniero para saber
            cuando y por qué usar una estructura de datos en particular.
            <br /><br />

            Las formas de crear las estructuras de datos de este artículo es una
            de tantas maneras de llegar al mismo resultado o similar, esta vez
            se usó clases, pero también se puede crear con funciones.
            <br /><br />
          </div>
        </li>

        <li>
          <h2>
            <a
              class="topics-title topics-title--ready"
              href="javascript:void(0)"
            >
              Test Driven Development (TDD)
            </a>
          </h2>
          <div class="topics-info">
            <h3>Qué es TDD?</h3>
            <p>
              Es un proceso en el cual se hacen los tests antes del codigo, se
              basa en el ciclo red, green, refactor, donde red(rojo) es hacer un
              test que falla(debe fallar), luego en la fase green(verde),
              creamos el codigo necesario para que el test pase, y en la ultima
              fase, refactor, el codigo puede ser mejorado/optimizado.
            </p>
            <figure>
              <img
                class="infografia"
                src="https://i.postimg.cc/14xc0XjH/0.png"
                alt="Red, green, refactor cycle in TDD"
              />
              <figcaption>Ciclo TDD</figcaption>
            </figure>

            <h3>Beneficios</h3>
            <h4>Testing se convierte en parte del desarrollo</h4>
            <p>
              Mayormente hacer tests se siente como una tarea pesada, por lo
              cual al aplicar TDD, los tests se convierten en parte del
              desarrollo.
            </p>
            <h4>Escribiremos código más limpio</h4>
            <p>
              Cuando aplicamos TDD, solemos escribir el mínimo código posible
              para hacer que el código pase.
            </p>
            <h4>Se reducen los bugs</h4>
            <p>
              Al usar TDD se escriben mas tests, lo cual tiende a reducir el
              numero de bugs.
            </p>

            <h3>Reglas del juego</h3>
            <p>
              Existe una versión corta con 2 reglas basadas en las propuestas
              por Uncle Bob:
            </p>
            <br />
            <ol>
              <li class="list">
                Escribe solo lo necesario para que un unit test falle.
              </li>
              <li class="list">
                Escribe solo suficiente codigo para hacer que el test que falló,
                pase.
              </li>
            </ol>

            <h3>
              Ejercicio: Aplicación en React para calcular el volumen de una
              esfera:
            </h3>

            <figure>
              <img
                class="infografia"
                src="https://i.postimg.cc/d3w1cKpB/1.png"
                alt="Intro TDD - Calcular volumen Estrella de la muerte"
              />
            </figure>

            <figure>
              <img
                class="infografia"
                src="https://i.postimg.cc/Wbp39TMp/2.png"
                alt="Fases del ciclo red, green, refactor del TDD"
              />
            </figure>

            <figure>
              <img
                class="infografia"
                src="https://i.postimg.cc/rpRzSj5S/5.png"
                alt="Primer test que falla (red)"
              />
            </figure>

            <figure>
              <img
                class="infografia"
                src="https://i.postimg.cc/8c4C10VV/6.png"
                alt="Primer test que pasa (green)"
              />
            </figure>

            <figure>
              <img
                class="infografia"
                src="https://i.postimg.cc/bJQJ5vCr/7.png"
                alt="Segundo Test que falla (red)"
              />
            </figure>

            <figure>
              <img
                class="infografia"
                src="https://i.postimg.cc/v8tTLcxS/8.png"
                alt="Segundo Test que pasa (green)"
              />
            </figure>

            <figure>
              <img
                class="infografia"
                src="https://i.postimg.cc/qRfqQKGW/9.png"
                alt="Tercer Test que falla (red)"
              />
            </figure>

            <figure>
              <img
                class="infografia"
                src="https://i.postimg.cc/NfN0SS46/10.png"
                alt="Tercer Test que pasa (green)"
              />
            </figure>

            <figure>
              <img
                class="infografia"
                src="https://i.postimg.cc/XYpvbLHT/11.png"
                alt="Imagen de la aplicacion en el navegador - Calculadora de volumen de esfera"
              />
            </figure>

            <figure>
              <img
                class="infografia"
                src="https://i.postimg.cc/MpNpKBgX/TDDeath-Star.png"
                alt="Consejos y retos finales sobre el app"
              />
              <figcaption>
                Fuente:
                <a
                  href="https://www.instagram.com/p/CigT04OOmwR/"
                  target="_blank"
                  rel="noopener"
                  >gsvidal.web</a
                >
              </figcaption>
            </figure>
          </div>
        </li>
      </ol>
    </section>

    <section class="topics-container topics-html">
      <ol class="numeracion-orden-principal">
        <li>
          <h2>
            <a
              class="topics-title topics-title--ready"
              href="javascript:void(0)"
            >
              Anatomía de una etiqueta HTML
            </a>
          </h2>
          <div class="topics-info">
            <h3 class="topics-subtitle">¿Qué es una etiqueta HTML?</h3>
            <p class="topics-copy">
              Las etiquetas HTML son elementos fundamentales que estructuran y
              dan significado al contenido web. Conocer su anatomía es esencial
              para escribir código semántico, accesible y mantenible.
            </p>

            <h4 class="topics-subtitle">Estructura Básica de una Etiqueta</h4>
            <p class="topics-copy">
              Una etiqueta HTML completa consta de varios componentes:
            </p>
            <ul class="bullet-list">
              <li><strong>Etiqueta de apertura:</strong> &lt;nombre&gt;</li>
              <li>
                <strong>Atributos:</strong> Propiedades que modifican el
                comportamiento
              </li>
              <li>
                <strong>Contenido:</strong> Texto, elementos anidados o datos
              </li>
              <li><strong>Etiqueta de cierre:</strong> &lt;/nombre&gt;</li>
            </ul>

            <h4 class="topics-subtitle">Tipos de Etiquetas</h4>
            <p class="topics-copy">
              Existen diferentes tipos de etiquetas según su comportamiento:
            </p>
            <ul class="bullet-list">
              <li>
                <strong>Etiquetas de bloque:</strong> Ocupan todo el ancho
                disponible
              </li>
              <li>
                <strong>Etiquetas en línea:</strong> Solo ocupan el espacio
                necesario
              </li>
              <li>
                <strong>Etiquetas auto-cerradas:</strong> No requieren etiqueta
                de cierre
              </li>
              <li>
                <strong>Etiquetas semánticas:</strong> Proporcionan significado
                al contenido
              </li>
            </ul>

            <h4 class="topics-subtitle">Atributos Fundamentales</h4>
            <p class="topics-copy">
              Los atributos más importantes que debes conocer:
            </p>
            <ul class="bullet-list">
              <li><strong>id:</strong> Identificador único en el documento</li>
              <li><strong>class:</strong> Clases CSS para estilizado</li>
              <li><strong>src:</strong> Fuente de recursos externos</li>
              <li><strong>alt:</strong> Texto alternativo para imágenes</li>
              <li><strong>href:</strong> Enlaces a otros recursos</li>
              <li>
                <strong>title:</strong> Información adicional al hacer hover
              </li>
            </ul>

            <h4 class="topics-subtitle">Mejores Prácticas</h4>
            <p class="topics-copy">Para escribir HTML eficiente y accesible:</p>
            <ul class="bullet-list">
              <li>Usar atributos alt descriptivos en imágenes</li>
              <li>Emplear id únicos y clases semánticas</li>
              <li>Anidar etiquetas correctamente</li>
              <li>Validar el código HTML regularmente</li>
              <li>Priorizar la accesibilidad en la estructura</li>
            </ul>
          </div>
        </li>

        <li>
          <h2>
            <a
              class="topics-title topics-title--ready"
              href="javascript:void(0)"
            >
              HTML Semántico
            </a>
          </h2>
          <div class="topics-info">
            <h3 class="topics-subtitle">¿Qué es HTML Semántico?</h3>
            <p class="topics-copy">
              HTML semántico utiliza etiquetas que describen el significado del
              contenido, no solo su apariencia. Esto mejora la accesibilidad,
              SEO y mantenibilidad del código, proporcionando estructura clara
              tanto para humanos como para máquinas.
            </p>

            <h4 class="topics-subtitle">Etiquetas Semánticas Principales</h4>
            <p class="topics-copy">
              Las etiquetas semánticas más importantes para estructurar
              contenido:
            </p>
            <ul class="bullet-list">
              <li>
                <strong>&lt;header&gt;:</strong> Encabezado de la página o
                sección
              </li>
              <li>
                <strong>&lt;nav&gt;:</strong> Navegación principal del sitio
              </li>
              <li>
                <strong>&lt;main&gt;:</strong> Contenido principal único en la
                página
              </li>
              <li>
                <strong>&lt;section&gt;:</strong> Sección temática del documento
              </li>
              <li>
                <strong>&lt;article&gt;:</strong> Contenido independiente y
                reutilizable
              </li>
              <li>
                <strong>&lt;aside&gt;:</strong> Contenido relacionado pero
                secundario
              </li>
              <li><strong>&lt;footer&gt;:</strong> Pie de página o sección</li>
            </ul>

            <h4 class="topics-subtitle">Etiquetas de Contenido</h4>
            <p class="topics-copy">
              Para estructurar el contenido dentro de las secciones:
            </p>
            <ul class="bullet-list">
              <li>
                <strong>&lt;h1&gt;-&lt;h6&gt;:</strong> Jerarquía de encabezados
              </li>
              <li><strong>&lt;p&gt;:</strong> Párrafos de texto</li>
              <li>
                <strong>&lt;figure&gt; y &lt;figcaption&gt;:</strong> Imágenes
                con descripción
              </li>
              <li><strong>&lt;blockquote&gt;:</strong> Citas textuales</li>
              <li><strong>&lt;time&gt;:</strong> Fechas y horas</li>
              <li><strong>&lt;address&gt;:</strong> Información de contacto</li>
            </ul>

            <h4 class="topics-subtitle">Beneficios del HTML Semántico</h4>
            <p class="topics-copy">
              El uso correcto de HTML semántico proporciona múltiples ventajas:
            </p>
            <ul class="bullet-list">
              <li>
                <strong>Accesibilidad:</strong> Mejor experiencia para lectores
                de pantalla
              </li>
              <li>
                <strong>SEO:</strong> Los motores de búsqueda entienden mejor el
                contenido
              </li>
              <li>
                <strong>Mantenibilidad:</strong> Código más fácil de leer y
                modificar
              </li>
              <li>
                <strong>Rendimiento:</strong> Navegadores pueden optimizar la
                renderización
              </li>
              <li>
                <strong>Futuro:</strong> Compatibilidad con nuevas tecnologías
                web
              </li>
            </ul>

            <h4 class="topics-subtitle">Mejores Prácticas</h4>
            <p class="topics-copy">
              Para implementar HTML semántico correctamente:
            </p>
            <ul class="bullet-list">
              <li>Usar una jerarquía lógica de encabezados (h1, h2, h3...)</li>
              <li>
                Evitar el uso excesivo de divs cuando hay etiquetas semánticas
              </li>
              <li>Emplear landmarks (header, nav, main, aside, footer)</li>
              <li>Proporcionar texto alternativo descriptivo en imágenes</li>
              <li>Validar la estructura semántica regularmente</li>
            </ul>
          </div>
        </li>

        <li>
          <h2>
            <a
              class="topics-title topics-title--ready"
              href="javascript:void(0)"
            >
              Parseo del código HTML
            </a>
          </h2>
          <div class="topics-info">
            <h3 class="topics-subtitle">¿Qué es el Parseo HTML?</h3>
            <p class="topics-copy">
              El parseo HTML es el proceso mediante el cual el navegador
              convierte el código HTML en un árbol de objetos (DOM) que puede
              ser manipulado y renderizado. Comprender este proceso es
              fundamental para optimizar el rendimiento y evitar problemas de
              renderizado.
            </p>

            <h4 class="topics-subtitle">Fases del Proceso de Parseo</h4>
            <p class="topics-copy">
              El parseo HTML ocurre en varias etapas secuenciales:
            </p>
            <ul class="bullet-list">
              <li>
                <strong>Tokenización:</strong> División del HTML en tokens
              </li>
              <li><strong>Construcción del árbol:</strong> Creación del DOM</li>
              <li>
                <strong>Análisis de dependencias:</strong> Identificación de
                recursos
              </li>
              <li>
                <strong>Renderizado:</strong> Generación de la representación
                visual
              </li>
            </ul>

            <h4 class="topics-subtitle">Tokenización</h4>
            <p class="topics-copy">Durante la tokenización, el navegador:</p>
            <ul class="bullet-list">
              <li>Identifica etiquetas de apertura y cierre</li>
              <li>Reconoce atributos y sus valores</li>
              <li>Procesa contenido de texto</li>
              <li>Maneja comentarios y doctypes</li>
            </ul>

            <h4 class="topics-subtitle">Construcción del DOM</h4>
            <p class="topics-copy">
              El navegador construye el DOM siguiendo reglas específicas:
            </p>
            <ul class="bullet-list">
              <li>
                <strong>Stack de elementos abiertos:</strong> Rastrea etiquetas
                no cerradas
              </li>
              <li>
                <strong>Corrección automática:</strong> Cierra etiquetas
                faltantes
              </li>
              <li>
                <strong>Anidamiento correcto:</strong> Mantiene la jerarquía
                apropiada
              </li>
              <li>
                <strong>Elementos especiales:</strong> Maneja elementos
                auto-cerrados
              </li>
            </ul>

            <h4 class="topics-subtitle">Optimizaciones del Navegador</h4>
            <p class="topics-copy">
              Los navegadores modernos implementan optimizaciones:
            </p>
            <ul class="bullet-list">
              <li>
                <strong>Parseo incremental:</strong> Procesa HTML mientras se
                descarga
              </li>
              <li>
                <strong>Preload de recursos:</strong> Descarga recursos críticos
                temprano
              </li>
              <li>
                <strong>Speculative parsing:</strong> Anticipa recursos
                necesarios
              </li>
              <li>
                <strong>Tree shaking:</strong> Elimina código no utilizado
              </li>
            </ul>

            <h4 class="topics-subtitle">
              Mejores Prácticas para Optimizar el Parseo
            </h4>
            <p class="topics-copy">Para mejorar el rendimiento del parseo:</p>
            <ul class="bullet-list">
              <li>Minificar HTML, CSS y JavaScript</li>
              <li>Usar etiquetas semánticas correctas</li>
              <li>Evitar HTML malformado</li>
              <li>Optimizar el orden de carga de recursos</li>
              <li>Emplear preload y prefetch estratégicamente</li>
            </ul>
          </div>
        </li>

        <li>
          <h2>
            <a
              class="topics-title topics-title--ready"
              href="javascript:void(0)"
            >
              Atributos de Accesibilidad
            </a>
          </h2>
          <div class="topics-info">
            <h3 class="topics-subtitle">
              ¿Qué son los Atributos de Accesibilidad?
            </h3>
            <p class="topics-copy">
              Los atributos de accesibilidad permiten que las tecnologías
              asistivas como lectores de pantalla comprendan mejor el contenido
              y la estructura de una página web. Son fundamentales para crear
              experiencias inclusivas que funcionen para todos los usuarios,
              independientemente de sus capacidades.
            </p>

            <h4 class="topics-subtitle">Atributos ARIA Esenciales</h4>
            <p class="topics-copy">
              Los atributos ARIA (Accessible Rich Internet Applications)
              proporcionan información semántica adicional:
            </p>
            <pre>
              <code class="language-html">
&lt;!-- Roles para definir el propósito del elemento --&gt;
&lt;div role="button" tabindex="0"&gt;Botón personalizado&lt;/div&gt;
&lt;div role="alert" aria-live="polite"&gt;Mensaje importante&lt;/div&gt;

&lt;!-- Estados y propiedades --&gt;
&lt;button aria-expanded="false" aria-controls="menu"&gt;
  Menú desplegable
&lt;/button&gt;
&lt;div id="menu" aria-hidden="true"&gt;Contenido del menú&lt;/div&gt;

&lt;!-- Etiquetas y descripciones --&gt;
&lt;input type="text" aria-label="Buscar productos" 
       aria-describedby="search-help"&gt;
&lt;div id="search-help"&gt;Ingresa el nombre del producto&lt;/div&gt;
              </code>
            </pre>

            <h4 class="topics-subtitle">Atributos de Accesibilidad Nativa</h4>
            <p class="topics-copy">
              HTML5 incluye atributos nativos que mejoran la accesibilidad:
            </p>
            <pre>
              <code class="language-html">
&lt;!-- Formularios accesibles --&gt;
&lt;label for="email"&gt;Correo electrónico:&lt;/label&gt;
&lt;input type="email" id="email" required 
       aria-required="true" aria-invalid="false"&gt;

&lt;!-- Imágenes con descripción --&gt;
&lt;img src="grafico.png" alt="Gráfico de ventas 2023" 
     role="img" aria-describedby="chart-desc"&gt;
&lt;div id="chart-desc"&gt;Muestra un aumento del 15% en ventas&lt;/div&gt;

&lt;!-- Navegación semántica --&gt;
&lt;nav aria-label="Navegación principal"&gt;
  &lt;ul role="menubar"&gt;
    &lt;li role="none"&gt;&lt;a href="/" role="menuitem"&gt;Inicio&lt;/a&gt;&lt;/li&gt;
    &lt;li role="none"&gt;&lt;a href="/about" role="menuitem"&gt;Acerca&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;
              </code>
            </pre>

            <h4 class="topics-subtitle">Opinión y Mejores Prácticas</h4>
            <p class="topics-copy">
              La accesibilidad no es opcional, es un derecho. Implementar
              atributos de accesibilidad correctamente no solo beneficia a
              usuarios con discapacidades, sino que mejora la experiencia para
              todos. Siempre prueba con lectores de pantalla y valida tu código
              con herramientas como axe-core. Recuerda: "Si no es accesible, no
              es profesional."
            </p>
            <ul class="bullet-list">
              <li>Usa roles ARIA solo cuando sea necesario</li>
              <li>Proporciona texto alternativo descriptivo en imágenes</li>
              <li>Implementa navegación por teclado</li>
              <li>Valida la accesibilidad regularmente</li>
              <li>
                Considera la experiencia de usuarios con diferentes capacidades
              </li>
            </ul>
          </div>
        </li>

        <li>
          <h2>
            <a
              class="topics-title topics-title--ready"
              href="javascript:void(0)"
            >
              Atributos de Eventos
            </a>
          </h2>
          <div class="topics-info">
            <h3 class="topics-subtitle">¿Qué son los Atributos de Eventos?</h3>
            <p class="topics-copy">
              Los atributos de eventos permiten ejecutar JavaScript directamente
              desde HTML cuando ocurren interacciones específicas del usuario.
              Aunque no son la práctica más moderna, son fundamentales para
              entender cómo funciona la interacción entre HTML y JavaScript.
            </p>

            <h4 class="topics-subtitle">Eventos de Interacción Comunes</h4>
            <p class="topics-copy">
              Los eventos más utilizados para crear interactividad básica:
            </p>
            <pre>
              <code class="language-html">
&lt;!-- Eventos de mouse --&gt;
&lt;button onclick="alert('¡Hola!')"&gt;Hacer clic&lt;/button&gt;
&lt;div onmouseover="this.style.backgroundColor='yellow'"
     onmouseout="this.style.backgroundColor='white'"&gt;
  Pasa el mouse aquí
&lt;/div&gt;

&lt;!-- Eventos de teclado --&gt;
&lt;input type="text" onkeyup="console.log('Tecla presionada')"
       onkeydown="if(event.key==='Enter') alert('Enter presionado')"&gt;

&lt;!-- Eventos de formulario --&gt;
&lt;form onsubmit="return validarFormulario()"&gt;
  &lt;input type="email" onblur="validarEmail(this)"&gt;
  &lt;button type="submit"&gt;Enviar&lt;/button&gt;
&lt;/form&gt;
              </code>
            </pre>

            <h4 class="topics-subtitle">Eventos de Carga y Estado</h4>
            <p class="topics-copy">
              Eventos que se ejecutan durante el ciclo de vida de la página:
            </p>
            <pre>
              <code class="language-html">
&lt;!-- Eventos de carga --&gt;
&lt;body onload="inicializarApp()" onunload="guardarDatos()"&gt;
  &lt;img src="imagen.jpg" onload="console.log('Imagen cargada')"
       onerror="console.log('Error al cargar imagen')"&gt;
  
  &lt;!-- Eventos de cambio --&gt;
  &lt;select onchange="filtrarProductos(this.value)"&gt;
    &lt;option value=""&gt;Todos&lt;/option&gt;
    &lt;option value="electronica"&gt;Electrónica&lt;/option&gt;
  &lt;/select&gt;
  
  &lt;!-- Eventos de foco --&gt;
  &lt;input type="text" onfocus="this.style.border='2px solid blue'"
         onblur="this.style.border='1px solid gray'"&gt;
&lt;/body&gt;
              </code>
            </pre>

            <h4 class="topics-subtitle">Opinión y Mejores Prácticas</h4>
            <p class="topics-copy">
              Aunque los atributos de eventos funcionan, la separación de
              responsabilidades es clave en desarrollo moderno. Prefiere
              addEventListener() en JavaScript puro o frameworks modernos. Los
              atributos de eventos son útiles para prototipado rápido, pero para
              aplicaciones serias, mantén el JavaScript separado.
            </p>
            <ul class="bullet-list">
              <li>Usa para prototipos rápidos, no en producción</li>
              <li>Separa JavaScript del HTML cuando sea posible</li>
              <li>Considera la accesibilidad en eventos de teclado</li>
              <li>Evita código JavaScript complejo en atributos</li>
              <li>Prefiere addEventListener() para mejor mantenibilidad</li>
            </ul>
          </div>
        </li>

        <li>
          <h2>
            <a
              class="topics-title topics-title--ready"
              href="javascript:void(0)"
            >
              Casos de Uso y Mejores Prácticas
            </a>
          </h2>
          <div class="topics-info">
            <h3 class="topics-subtitle">Aplicando HTML en el Mundo Real</h3>
            <p class="topics-copy">
              Conocer la sintaxis HTML es solo el primer paso. La verdadera
              maestría viene de saber cuándo y cómo aplicar cada elemento
              correctamente. Los casos de uso reales te enseñan a pensar como
              desarrollador y a crear código que realmente funcione.
            </p>

            <h4 class="topics-subtitle">Estructura de Página Completa</h4>
            <p class="topics-copy">
              Ejemplo de una página web bien estructurada:
            </p>
            <pre>
              <code class="language-html">
&lt;!DOCTYPE html&gt;
&lt;html lang="es"&gt;
&lt;head&gt;
  &lt;meta charset="UTF-8"&gt;
  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
  &lt;title&gt;Mi Blog Personal&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;header&gt;
    &lt;nav aria-label="Navegación principal"&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href="#inicio"&gt;Inicio&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href="#blog"&gt;Blog&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href="#contacto"&gt;Contacto&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/nav&gt;
  &lt;/header&gt;
  
  &lt;main&gt;
    &lt;article&gt;
      &lt;header&gt;
        &lt;h1&gt;Mi Primer Artículo&lt;/h1&gt;
        &lt;time datetime="2024-01-15"&gt;15 de Enero, 2024&lt;/time&gt;
      &lt;/header&gt;
      &lt;p&gt;Contenido del artículo...&lt;/p&gt;
    &lt;/article&gt;
  &lt;/main&gt;
  
  &lt;footer&gt;
    &lt;p&gt;&copy; 2024 Mi Blog. Todos los derechos reservados.&lt;/p&gt;
  &lt;/footer&gt;
&lt;/body&gt;
&lt;/html&gt;
              </code>
            </pre>

            <h4 class="topics-subtitle">Formulario de Contacto Accesible</h4>
            <p class="topics-copy">
              Implementación de un formulario siguiendo mejores prácticas:
            </p>
            <pre>
              <code class="language-html">
&lt;form action="/contacto" method="POST" novalidate&gt;
  &lt;fieldset&gt;
    &lt;legend&gt;Información de Contacto&lt;/legend&gt;
    
    &lt;div&gt;
      &lt;label for="nombre"&gt;Nombre completo:&lt;/label&gt;
      &lt;input type="text" id="nombre" name="nombre" required
             aria-describedby="nombre-error"&gt;
      &lt;div id="nombre-error" role="alert" aria-live="polite"&gt;&lt;/div&gt;
    &lt;/div&gt;
    
    &lt;div&gt;
      &lt;label for="email"&gt;Correo electrónico:&lt;/label&gt;
      &lt;input type="email" id="email" name="email" required
             aria-describedby="email-help"&gt;
      &lt;div id="email-help"&gt;Nunca compartiremos tu email&lt;/div&gt;
    &lt;/div&gt;
    
    &lt;div&gt;
      &lt;label for="mensaje"&gt;Mensaje:&lt;/label&gt;
      &lt;textarea id="mensaje" name="mensaje" rows="5" required
                aria-describedby="mensaje-help"&gt;&lt;/textarea&gt;
      &lt;div id="mensaje-help"&gt;Máximo 500 caracteres&lt;/div&gt;
    &lt;/div&gt;
    
    &lt;button type="submit"&gt;Enviar Mensaje&lt;/button&gt;
  &lt;/fieldset&gt;
&lt;/form&gt;
              </code>
            </pre>

            <h4 class="topics-subtitle">Opinión y Mejores Prácticas</h4>
            <p class="topics-copy">
              El HTML semántico no es solo una moda, es la base de una web
              accesible y mantenible. Cada etiqueta tiene un propósito
              específico, y usarla correctamente mejora tanto la experiencia del
              usuario como el SEO. Recuerda: "HTML es para estructura, CSS para
              presentación, JavaScript para comportamiento."
            </p>
            <ul class="bullet-list">
              <li>Usa etiquetas semánticas apropiadas</li>
              <li>Implementa accesibilidad desde el inicio</li>
              <li>Valida tu HTML regularmente</li>
              <li>Mantén la estructura lógica y jerárquica</li>
              <li>Considera la experiencia en diferentes dispositivos</li>
            </ul>
          </div>
        </li>
      </ol>
    </section>

    <section class="topics-container topics-css">
      <ol class="numeracion-orden-principal">
        <li>
          <h2>
            <a
              class="topics-title topics-title--ready"
              href="javascript:void(0)"
            >
              Anatomía de una Regla CSS
            </a>
          </h2>
          <div class="topics-info">
            <h3 class="topics-subtitle">¿Qué es una Regla CSS?</h3>
            <p class="topics-copy">
              Las reglas CSS son los bloques fundamentales que definen cómo se
              ven los elementos HTML. Cada regla consta de un selector y una
              declaración, permitiendo aplicar estilos de manera precisa y
              mantenible.
            </p>

            <h4 class="topics-subtitle">Estructura de una Regla CSS</h4>
            <p class="topics-copy">
              Una regla CSS completa tiene la siguiente estructura:
            </p>
            <pre>
              <code class="language-css">
selector {
  propiedad: valor;
}
              </code>
            </pre>

            <h4 class="topics-subtitle">Componentes Principales</h4>
            <p class="topics-copy">
              Cada regla CSS contiene elementos esenciales:
            </p>
            <ul class="bullet-list">
              <li>
                <strong>Selector:</strong> Define qué elementos se estilizan
              </li>
              <li><strong>Propiedades:</strong> Qué aspecto se modifica</li>
              <li><strong>Valores:</strong> Cómo se modifica el aspecto</li>
              <li>
                <strong>Declaraciones:</strong> Combinación de propiedad y valor
              </li>
            </ul>

            <h4 class="topics-subtitle">Tipos de Selectores</h4>
            <p class="topics-copy">
              Los selectores determinan qué elementos se ven afectados:
            </p>
            <pre>
              <code class="language-css">
/* Selector de elemento */
h1 { color: blue; }

/* Selector de clase */
.titulo { font-size: 24px; }

/* Selector de ID */
#header { background: gray; }

/* Selector descendente */
div p { margin: 10px; }

/* Selector de atributo */
input[type="text"] { border: 1px solid #ccc; }
              </code>
            </pre>

            <h4 class="topics-subtitle">Propiedades y Valores</h4>
            <p class="topics-copy">
              Las propiedades definen qué aspecto cambiar, mientras que los
              valores especifican cómo cambiarlo:
            </p>
            <pre>
              <code class="language-css">
.boton {
  background-color: #007bff;  /* Color de fondo */
  color: white;              /* Color del texto */
  padding: 10px 20px;        /* Espaciado interno */
  border: none;              /* Sin borde */
  border-radius: 4px;        /* Esquinas redondeadas */
  cursor: pointer;           /* Cursor de mano */
}
              </code>
            </pre>

            <h4 class="topics-subtitle">Mejores Prácticas</h4>
            <p class="topics-copy">Para escribir CSS eficiente y mantenible:</p>
            <ul class="bullet-list">
              <li>Usar nombres de clase descriptivos y semánticos</li>
              <li>Agrupar propiedades relacionadas</li>
              <li>Emplear valores abreviados cuando sea posible</li>
              <li>Comentar secciones complejas del código</li>
              <li>Validar CSS regularmente</li>
            </ul>
          </div>
        </li>

        <li>
          <h2>
            <a
              class="topics-title topics-title--ready"
              href="javascript:void(0)"
            >
              Metodología BEM
            </a>
          </h2>
          <div class="topics-info">
            Existen varias metodologías o convenciones para nombrar a las
            classes en CSS. Entre las principales tenemos a BEM, OOCSS, SMACSS,
            SUITCSS, etc. <br /><br />
            Estas se utilizan para organizar nuestro código en CSS y ayuda a
            mantener CSSs extensos.
            <h4>¿Qué es BEM?</h4>
            BEM es una convención o standard para nombrar clases en CSS.
            <h4>¿Porqué utilizar BEM?</h4>
            Primero veamos por qué utilizarlo sobre las otras metodologías
            mencionadas líneas arriba, es menos confusa que otros métodos
            (SMACSS) pero aun nos brinda una buena arquitectura(OOCSS) y con una
            terminología que podemos reconocer.
            <br /><br />
            Podemos encontrar <strong>3 beneficios</strong> al utilizar BEM:
            <ol>
              <li>Comunica propósito o función.</li>
              <li>Comunica estructura de compentes.</li>
              <li>Proporciona una especificidad baja.</li>
            </ol>

            <br />
            <strong>BEM</strong> significa: <br />
            <h4>Blocks</h4>
            <ol>
              <li>
                Los bloques son contenedores o el contexto donde están situados
                los elementos.
              </li>
              <li>
                Suelen ser etiquetas semánticas. ejem: (main, section, header,
                footer, etc.)
              </li>
              <li>Son independientes de otros bloques/elementos.</li>
            </ol>
            <br />
            Código en CSS:
            <pre>
            <code class="language-css">
              .block {

              }
            </code>
          </pre>
            Ejemplo:
            <pre>
            <code class="language-css">
              .header {

              }
            </code>
          </pre>

            <h4>Elements</h4>
            <ol>
              <li>
                Los elementos son parte de un bloque y no tienen significado
                semántico fuera de ese bloque.
              </li>
              <li>
                Los elementos son escritos usando el nombre del bloque conectado
                por dos guiones abajo (underscore) a ellos.
              </li>
            </ol>
            Código en CSS:
            <pre>
            <code class="language-css">
              .block__element {

              }
            </code>
          </pre>
            Ejemplo:
            <pre>
            <code class="language-css">
              .header__navbar {

              }
            </code>
          </pre>

            <h4>Modifiers</h4>
            <ol>
              <li>
                Los modificadores son un <i>flag</i> en un bloque o un elemento,
                se usa para cambiar apariencia, comportamiento o estado.
              </li>
              <li>Ofrecen una gran ventaja: <i>Modularidad</i>.</li>
              <li>
                Al usar modificadores se facilita la
                <i>reutilización de código</i> e incentiva a la
                <i>programación por componentes</i>.
              </li>
            </ol>
            <br />

            <div class="modifiers-code-division">
              <div class="modifiers-left">
                Codigo en CSS(Modificador de un bloque):
                <pre>
                <code class="language-css">
                  .block--modifier {
                  
                  }
                </code>
              </pre>
                ó Modificador de un elemento:
                <pre>
                <code class="language-css">
                    .block__element--modifier {
                    
                    }
                </code>
              </pre>
                Ejemplo práctico: <br />
                CSS:
                <pre>
              <code class="language-css">
                .hero__copy--languages {
                
                }
              </code>
            </pre>
              </div>

              <div class="modifiers-right">
                Codigo en HTML(Modificador de un bloque):
                <pre>
                  <code class="language-markup">
                    <label for="block--modifier"></label>
                  <textarea readonly  id="block--modifier" title="language-markup">
                      <tag class ="block block--modifier">
                      </tag>
                    </textarea>
                  </code>
                </pre>
                ó Modificador de un elemento:
                <pre>
                  <code class="language-markup">
                    <label for="block__element--modifier"></label>
                  <textarea readonly  id="block__element--modifier" title="language-markup">
                      <tag class ="block__element block__element--modifier">
                      </tag>
                    </textarea>
                  </code>
                </pre>
                Ejemplo práctico: <br />
                HTML:
                <pre>
                <code class="language-markup">
                  <label for="hero__copy--languages"></label>
                  <textarea readonly  id="hero__copy--languages" title="language-markup">
                    <p class ="hero__copy hero__copy--languages">Contenido
                    </p>
                  </textarea>
                </code>
              </pre>
              </div>
            </div>

            <p>
              A continuación podemos ver un ejemplo visual de esta metodología:
            </p>
            <figure>
              <img
                class="infografia"
                src="https://i.postimg.cc/VvdRVKkf/GSVIDAL-WEB-5.gif"
                alt="Ejemplo metodología BEM"
              />
            </figure>
            <p>
              Puedes ver la aplicación de la metodología BEM en el proyecto de
              maquetación del sitio web de la plataforma
              <a class="enlaces-externos" href="https://www.codacy.com"
                >CODACY</a
              >, codeada por el grupo
              <strong
                ><a
                  class="enlaces-externos"
                  href="https://github.com/bit-hug-learning/codacy-code-project"
                  >Bit-Hug</a
                ></strong
              >. Puedes encontrar BEM en las siguientes secciones del repo/web:
            </p>
            <br /><br />
            <ol>
              <li>section-1 (hero)</li>
              <li>section-2</li>
              <li>section-7</li>
              <li>footer</li>
            </ol>
          </div>
        </li>

        <li>
          <h2>
            <a
              class="topics-title topics-title--ready"
              href="javascript:void(0)"
            >
              Orden de declaración
            </a>
          </h2>
          <div class="topics-info">
            <p>
              A continuación, las 3 formas de como controlar el orden al
              declarar en CSS son (prioridad va de mayor 1. a menor 3.):
            </p>

            <ol>
              <li>Origen e Importancia</li>
              <li>Especificidad</li>
              <li>Posición / Orden de las fuentes de codigo CSS</li>
            </ol>

            <p>
              Recordar que mientras más alta sea alguna de estas 3 formas, más
              alta la relevancia o prioridad será la declaración CSS
            </p>

            <h3 class="topics-subtitle">Origen e Importancia</h3>
            <ol>
              <li>Primero se aplican los estilos del navegador</li>
              <li>
                Luego se aplican los estilos de nuestras declaraciones en
                nuestros archivos .css
              </li>
              <li>
                Finalmente se aplican las declaraciones con
                <code> !important</code>
              </li>
            </ol>
            <p>
              Una regla práctica para recordar la importancia de las
              declaraciones CSS, es la siguiente:
            </p>
            <ol>
              <li>transitions</li>
              <li>user-agent !important</li>
              <li>user !important</li>
              <li>author !important</li>
              <li>animations</li>
              <li>author</li>
              <li>user</li>
              <li>user-agent</li>
            </ol>
            <p>Donde la importancia es mayor en 1. y menor en 8.</p>
            <p>
              <strong>Notas: </strong>Recordar que el uso de !important es
              considerado una mala práctica, ya que puede romper nuestros
              estilos o llegar al punto de usarlo cada vez que no sepamos como
              funciona CSS
            </p>

            <h3 class="topics-subtitle">Especificidad</h3>

            <ol>
              <li>inline</li>
              <li>id</li>
              <li>clases / selectores de atributo / pseudo-clases</li>
              <li>tipo / pseudo-elementos</li>
            </ol>
            <p>Donde la especificidad es mayor en 1. y menor en 4.</p>

            <h3 class="topics-subtitle">
              Posición / Orden de las fuentes de codigo CSS
            </h3>

            <ol>
              <li>
                CSS internos (al utilizar la etiqueta &lt;style&gt; dentro de la
                etiqueta &lt;head&gt;)
              </li>
              <li>
                CSS externos (al utilizar la etiqueta &lt;link&gt; haciendo
                referencia a un css externo)
              </li>
              <li>Orden en declaraciones CSS</li>
            </ol>
            <p>Donde la posicion es mayor en 1. y menor en 3.</p>

            <p>
              Aquí se aplica el algoritmo de Cascada que tiene CSS, las
              declaraciones y/o reglas CSS que estén por debajo sobreescribirán
              o anularán a las que estén por arriba, en caso de conflicto.
              <br /><br /><strong>Notas: </strong>
              También tener en cuenta que al llamar en el archivo .html varios
              archivos .css, los de abajo también pueden reescribir a los de
              arriba.
            </p>
          </div>
        </li>

        <li>
          <h2>
            <a
              class="topics-title topics-title--ready"
              href="javascript:void(0)"
            >
              Modelo de Caja
            </a>
          </h2>
          <div class="topics-info">
            <h3 class="topics-subtitle">¿Qué es el Modelo de Caja?</h3>
            <p class="topics-copy">
              El modelo de caja es la base fundamental del diseño CSS. Cada
              elemento HTML se comporta como una caja rectangular compuesta por
              contenido, padding, borde y margen. Comprender este modelo es
              esencial para controlar el espaciado y el layout de tus páginas
              web.
            </p>

            <div class="box-model-demo">
              <div class="box-model-container">
                <div class="box-model-margin">
                  <div class="box-model-border">
                    <div class="box-model-padding">
                      <div class="box-model-content">Content</div>
                    </div>
                  </div>
                </div>
              </div>

              <div class="box-model-legend">
                <div class="legend-item legend-margin">
                  <div class="legend-color"></div>
                  <span>Margin</span>
                </div>
                <div class="legend-item legend-border">
                  <div class="legend-color"></div>
                  <span>Border</span>
                </div>
                <div class="legend-item legend-padding">
                  <div class="legend-color"></div>
                  <span>Padding</span>
                </div>
                <div class="legend-item legend-content">
                  <div class="legend-color"></div>
                  <span>Content</span>
                </div>
              </div>
            </div>

            <h4 class="topics-subtitle">Componentes del Modelo de Caja</h4>
            <p class="topics-copy">
              Los cuatro componentes principales que forman cada caja:
            </p>
            <pre>
              <code class="language-css">
/* Ejemplo básico del modelo de caja */
.caja {
  width: 200px;           /* Ancho del contenido */
  height: 100px;          /* Alto del contenido */
  padding: 20px;          /* Espacio interno */
  border: 2px solid #333; /* Borde */
  margin: 10px;           /* Espacio externo */
  background-color: #f0f0f0;
}

/* Desglose detallado */
.elemento {
  /* Contenido */
  width: 300px;
  height: 150px;
  
  /* Padding (espacio interno) */
  padding-top: 10px;
  padding-right: 15px;
  padding-bottom: 10px;
  padding-left: 15px;
  /* Equivale a: padding: 10px 15px; */
  
  /* Border (borde) */
  border-width: 1px;
  border-style: solid;
  border-color: #ccc;
  /* Equivale a: border: 1px solid #ccc; */
  
  /* Margin (espacio externo) */
  margin: 20px auto; /* 20px arriba/abajo, auto izquierda/derecha */
}
              </code>
            </pre>

            <h4 class="topics-subtitle">Box-Sizing: La Diferencia Clave</h4>
            <p class="topics-copy">
              La propiedad box-sizing determina cómo se calcula el tamaño total:
            </p>
            <pre>
              <code class="language-css">
/* content-box (por defecto) */
.caja-content {
  box-sizing: content-box;
  width: 200px;
  padding: 20px;
  border: 2px solid #000;
  /* Tamaño total: 200px + 40px (padding) + 4px (border) = 244px */
}

/* border-box (recomendado) */
.caja-border {
  box-sizing: border-box;
  width: 200px;
  padding: 20px;
  border: 2px solid #000;
  /* Tamaño total: exactamente 200px */
}

/* Aplicar border-box globalmente */
* {
  box-sizing: border-box;
}
              </code>
            </pre>

            <h4 class="topics-subtitle">Opinión y Mejores Prácticas</h4>
            <p class="topics-copy">
              El modelo de caja es la piedra angular del CSS. Siempre usa
              box-sizing: border-box para evitar sorpresas con los cálculos de
              tamaño. El colapso de márgenes puede ser confuso al principio,
              pero una vez que lo entiendes, te da control total sobre el
              espaciado.
            </p>
            <ul class="bullet-list">
              <li>Usa box-sizing: border-box globalmente</li>
              <li>Comprende el colapso de márgenes verticales</li>
              <li>Usa padding para espaciado interno, margin para externo</li>
              <li>Considera el impacto en responsive design</li>
              <li>Prueba en diferentes navegadores para consistencia</li>
            </ul>
          </div>
        </li>

        <li>
          <h2>
            <a
              class="topics-title topics-title--ready"
              href="javascript:void(0)"
            >
              Flex vs Grid
            </a>
          </h2>
          <div class="topics-info">
            <h3 class="topics-subtitle">
              Flexbox vs CSS Grid: ¿Cuándo Usar Cada Uno?
            </h3>
            <p class="topics-copy">
              Flexbox y CSS Grid son las dos herramientas más poderosas para
              crear layouts modernos. Aunque pueden parecer similares, cada una
              tiene su propósito específico. Flexbox es ideal para componentes
              unidimensionales, mientras que Grid es perfecto para layouts
              bidimensionales complejos.
            </p>

            <h4 class="topics-subtitle">Flexbox: Para Componentes</h4>
            <p class="topics-copy">
              Flexbox es perfecto para alinear elementos en una sola dirección:
            </p>
            <pre>
              <code class="language-css">
/* Navegación horizontal */
.nav {
  display: flex;
  justify-content: space-between; /* Distribuye el espacio */
  align-items: center;           /* Centra verticalmente */
  padding: 1rem;
}

.nav-item {
  flex: 1; /* Crecimiento igual para todos */
}

/* Botón con icono y texto */
.boton {
  display: flex;
  align-items: center;
  gap: 0.5rem; /* Espacio entre icono y texto */
}

/* Card con contenido flexible */
.card {
  display: flex;
  flex-direction: column;
  height: 100%;
}

.card-content {
  flex: 1; /* Ocupa el espacio disponible */
}

.card-footer {
  margin-top: auto; /* Se pega al final */
}
              </code>
            </pre>

            <h4 class="topics-subtitle">CSS Grid: Para Layouts</h4>
            <p class="topics-copy">
              Grid es ideal para layouts complejos con filas y columnas:
            </p>
            <pre>
              <code class="language-css">
/* Layout principal de página */
.layout {
  display: grid;
  grid-template-columns: 200px 1fr 200px;
  grid-template-rows: auto 1fr auto;
  grid-template-areas: 
    "header header header"
    "sidebar main aside"
    "footer footer footer";
  min-height: 100vh;
}

.header { grid-area: header; }
.sidebar { grid-area: sidebar; }
.main { grid-area: main; }
.aside { grid-area: aside; }
.footer { grid-area: footer; }

/* Grid responsivo */
.grid-responsive {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
  gap: 1rem;
}

/* Grid con líneas nombradas */
.grid-lines {
  display: grid;
  grid-template-columns: [start] 1fr [content-start] 2fr [content-end] 1fr [end];
  grid-template-rows: [header] auto [main] 1fr [footer] auto;
}
              </code>
            </pre>

            <h4 class="topics-subtitle">Opinión y Mejores Prácticas</h4>
            <p class="topics-copy">
              No son competidores, son complementarios. Usa Flexbox para
              componentes individuales (botones, cards, navegación) y Grid para
              layouts generales (páginas, secciones). La combinación de ambos te
              da control total sobre el diseño. Recuerda: "Flexbox para
              componentes, Grid para layouts."
            </p>
            <ul class="bullet-list">
              <li>Flexbox para alineación unidimensional</li>
              <li>Grid para layouts bidimensionales</li>
              <li>Combina ambos para máxima flexibilidad</li>
              <li>Usa gap en lugar de margin para espaciado</li>
              <li>Considera el soporte en navegadores antiguos</li>
            </ul>
          </div>
        </li>

        <li>
          <h2>
            <a
              class="topics-title topics-title--ready"
              href="javascript:void(0)"
            >
              Posicionamiento
            </a>
          </h2>
          <div class="topics-info">
            <h3 class="topics-subtitle">¿Qué es el Posicionamiento CSS?</h3>
            <p class="topics-copy">
              El posicionamiento CSS controla cómo se colocan los elementos en
              la página. Desde el flujo normal del documento hasta elementos
              flotantes y superpuestos, el posicionamiento es clave para crear
              layouts precisos y controlar la jerarquía visual de tus diseños.
            </p>

            <h4 class="topics-subtitle">Tipos de Posicionamiento</h4>
            <p class="topics-copy">
              Los cinco valores principales de la propiedad position:
            </p>
            <pre>
              <code class="language-css">
/* Static (por defecto) - Flujo normal */
.elemento-static {
  position: static;
  /* Sigue el flujo normal del documento */
}

/* Relative - Relativo a su posición original */
.elemento-relative {
  position: relative;
  top: 10px;    /* Se mueve 10px hacia abajo */
  left: 20px;   /* Se mueve 20px hacia la derecha */
  /* Mantiene su espacio en el flujo */
}

/* Absolute - Relativo al contenedor posicionado más cercano */
.elemento-absolute {
  position: absolute;
  top: 0;
  right: 0;
  /* Se saca del flujo normal */
}

/* Fixed - Relativo al viewport */
.elemento-fixed {
  position: fixed;
  bottom: 20px;
  right: 20px;
  /* Siempre visible, no se mueve con el scroll */
}

/* Sticky - Híbrido entre relative y fixed */
.elemento-sticky {
  position: sticky;
  top: 0;
  /* Se comporta como relative hasta llegar a top: 0 */
}
              </code>
            </pre>

            <h4 class="topics-subtitle">Z-Index y Stacking Context</h4>
            <p class="topics-copy">
              Controla la superposición de elementos con z-index:
            </p>
            <pre>
              <code class="language-css">
/* Z-index básico */
.modal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.5);
  z-index: 1000; /* Por encima de otros elementos */
}

.modal-content {
  position: relative;
  z-index: 1001; /* Por encima del fondo del modal */
}

/* Stacking context */
.contenedor {
  position: relative;
  z-index: 1; /* Crea nuevo contexto de apilamiento */
}

.elemento-hijo {
  position: absolute;
  z-index: 10; /* Solo se compara con otros elementos del mismo contexto */
}

/* Float y clear */
.imagen-float {
  float: left;
  margin-right: 1rem;
}

.texto {
  clear: both; /* Evita que el texto se envuelva alrededor del float */
}
              </code>
            </pre>

            <h4 class="topics-subtitle">Opinión y Mejores Prácticas</h4>
            <p class="topics-copy">
              El posicionamiento es una herramienta poderosa pero puede volverse
              complejo rápidamente. Usa position: relative para ajustes menores,
              absolute para overlays y modales, y fixed para elementos que deben
              permanecer visibles. Evita z-index muy altos y considera usar CSS
              Grid o Flexbox para layouts modernos.
            </p>
            <ul class="bullet-list">
              <li>Usa relative para ajustes menores de posición</li>
              <li>Absolute para elementos superpuestos</li>
              <li>Fixed para elementos que deben permanecer visibles</li>
              <li>Mantén z-index bajo control (máximo 100)</li>
              <li>Considera alternativas modernas como Grid</li>
            </ul>
          </div>
        </li>
      </ol>
    </section>

    <section class="topics-container topics-react">
      <ol class="numeracion-orden-principal">
        <li>
          <h2>
            <a
              class="topics-title topics-title--ready"
              href="javascript:void(0)"
            >
              React 101
            </a>
          </h2>
          <div class="topics-info">
            <h3 class="topics-subtitle">¿Qué es React?</h3>
            <p class="topics-copy">
              React es una biblioteca de JavaScript desarrollada por Facebook
              para construir interfaces de usuario interactivas y reutilizables.
              Su enfoque basado en componentes y el Virtual DOM la convierten en
              una herramienta poderosa para el desarrollo frontend moderno.
            </p>

            <h4 class="topics-subtitle">Características Principales</h4>
            <p class="topics-copy">
              React se destaca por sus características únicas:
            </p>
            <ul class="bullet-list">
              <li><strong>Componentes:</strong> Bloques reutilizables de UI</li>
              <li>
                <strong>Virtual DOM:</strong> Optimización del rendimiento
              </li>
              <li>
                <strong>JSX:</strong> Sintaxis que combina HTML y JavaScript
              </li>
              <li>
                <strong>Unidireccional:</strong> Flujo de datos predecible
              </li>
              <li>
                <strong>Ecosistema:</strong> Herramientas y librerías
                complementarias
              </li>
            </ul>

            <h4 class="topics-subtitle">Opinión y Mejores Prácticas</h4>
            <p class="topics-copy">
              React revolucionó el desarrollo frontend al introducir el concepto
              de componentes reutilizables y el Virtual DOM. Su curva de
              aprendizaje es moderada, pero una vez dominado, permite crear
              aplicaciones escalables y mantenibles. La clave está en entender
              el flujo de datos unidireccional y aprovechar el ecosistema de
              herramientas.
            </p>
            <ul class="bullet-list">
              <li>Comienza con componentes funcionales</li>
              <li>Entiende el flujo de props y state</li>
              <li>Practica con JSX y eventos</li>
              <li>Explora el ecosistema de herramientas</li>
              <li>Mantente actualizado con las últimas características</li>
            </ul>
          </div>
        </li>

        <li>
          <h2>
            <a
              class="topics-title topics-title--ready"
              href="javascript:void(0)"
            >
              Elementos y Componentes en React
            </a>
          </h2>
          <div class="topics-info">
            <h3 class="topics-subtitle">
              ¿Qué son los Elementos y Componentes?
            </h3>
            <p class="topics-copy">
              Los elementos son la unidad más pequeña de React, mientras que los
              componentes son funciones o clases que devuelven elementos. Esta
              distinción es fundamental para entender cómo React construye la
              interfaz de usuario de manera eficiente y reutilizable.
            </p>

            <h4 class="topics-subtitle">Elementos vs Componentes</h4>
            <p class="topics-copy">
              La diferencia clave entre elementos y componentes:
            </p>
            <pre>
              <code class="language-jsx">
// Elemento - descripción de lo que quieres ver
const element = &lt;h1&gt;Hola, mundo!&lt;/h1&gt;;

// Componente - función que devuelve elementos
function Saludo() {
  return &lt;h1&gt;Hola, mundo!&lt;/h1&gt;;
}

// Componente con props
function SaludoPersonalizado({ nombre }) {
  return &lt;h1&gt;Hola, {nombre}!&lt;/h1&gt;;
}

// Uso del componente
const elemento = &lt;SaludoPersonalizado nombre="React" /&gt;;
              </code>
            </pre>

            <h4 class="topics-subtitle">Tipos de Componentes</h4>
            <p class="topics-copy">
              React ofrece diferentes formas de crear componentes:
            </p>
            <pre>
              <code class="language-jsx">
// Componente funcional (recomendado)
function MiComponente() {
  return &lt;div&gt;Componente funcional&lt;/div&gt;;
}

// Componente de clase
class MiComponenteClase extends React.Component {
  render() {
    return &lt;div&gt;Componente de clase&lt;/div&gt;;
  }
}

// Componente con arrow function
const MiComponenteArrow = () =&gt; {
  return &lt;div&gt;Componente arrow&lt;/div&gt;;
};
              </code>
            </pre>

            <h4 class="topics-subtitle">Opinión y Mejores Prácticas</h4>
            <p class="topics-copy">
              Los componentes funcionales son el futuro de React. Son más
              simples, tienen mejor rendimiento y son más fáciles de testear. La
              clave está en mantener los componentes pequeños, enfocados en una
              sola responsabilidad y bien documentados.
            </p>
            <ul class="bullet-list">
              <li>Prefiere componentes funcionales</li>
              <li>Mantén componentes pequeños y enfocados</li>
              <li>Usa nombres descriptivos para componentes</li>
              <li>Extrae lógica compleja a hooks personalizados</li>
              <li>Documenta props con PropTypes o TypeScript</li>
            </ul>
          </div>
        </li>

        <li>
          <h2>
            <a
              class="topics-title topics-title--ready"
              href="javascript:void(0)"
            >
              Estados y Props
            </a>
          </h2>
          <div class="topics-info">
            <h3 class="topics-subtitle">¿Qué son Estados y Props?</h3>
            <p class="topics-copy">
              Los estados (state) y props son los dos pilares fundamentales para
              manejar datos en React. Los props permiten pasar datos de
              componentes padre a hijo, mientras que el state maneja datos
              internos que pueden cambiar durante el ciclo de vida del
              componente.
            </p>

            <h4 class="topics-subtitle">Props - Datos Inmutables</h4>
            <p class="topics-copy">
              Los props son datos que se pasan de componente padre a hijo:
            </p>
            <pre>
              <code class="language-jsx">
// Componente padre
function App() {
  const usuario = "Juan";
  const edad = 25;
  
  return (
    &lt;SaludoUsuario 
      nombre={usuario} 
      edad={edad}
      esActivo={true}
    /&gt;
  );
}

// Componente hijo
function SaludoUsuario({ nombre, edad, esActivo }) {
  return (
    &lt;div&gt;
      &lt;h1&gt;Hola, {nombre}!&lt;/h1&gt;
      &lt;p&gt;Tienes {edad} años&lt;/p&gt;
      {esActivo && &lt;p&gt;Usuario activo&lt;/p&gt;}
    &lt;/div&gt;
  );
}
              </code>
            </pre>

            <h4 class="topics-subtitle">State - Datos Mutables</h4>
            <p class="topics-copy">El state maneja datos que pueden cambiar:</p>
            <pre>
              <code class="language-jsx">
import { useState } from 'react';

function Contador() {
  const [contador, setContador] = useState(0);
  
  const incrementar = () =&gt; {
    setContador(contador + 1);
  };
  
  const decrementar = () =&gt; {
    setContador(contador - 1);
  };
  
  return (
    &lt;div&gt;
      &lt;h2&gt;Contador: {contador}&lt;/h2&gt;
      &lt;button onClick={incrementar}&gt;+&lt;/button&gt;
      &lt;button onClick={decrementar}&gt;-&lt;/button&gt;
    &lt;/div&gt;
  );
}
              </code>
            </pre>

            <h4 class="topics-subtitle">Opinión y Mejores Prácticas</h4>
            <p class="topics-copy">
              La gestión correcta de state y props es crucial para aplicaciones
              React escalables. Siempre eleva el state al componente común más
              cercano y usa props para comunicación entre componentes. Recuerda
              que los props son inmutables y el state debe actualizarse con
              setState o hooks.
            </p>
            <ul class="bullet-list">
              <li>Props son inmutables, state es mutable</li>
              <li>Eleva el state al componente común más cercano</li>
              <li>Usa destructuring para props</li>
              <li>Evita mutar el state directamente</li>
              <li>Considera usar Context para state global</li>
            </ul>
          </div>
        </li>

        <li>
          <h2>
            <a
              class="topics-title topics-title--ready"
              href="javascript:void(0)"
            >
              Hooks Avanzados
            </a>
          </h2>
          <div class="topics-info">
            <h3 class="topics-subtitle">¿Qué son los Hooks Avanzados?</h3>
            <p class="topics-copy">
              Los hooks avanzados van más allá de useState y useEffect,
              ofreciendo funcionalidades específicas para casos de uso
              complejos. Hooks como useMemo, useCallback, useRef y useContext
              permiten optimizar rendimiento y manejar casos avanzados de manera
              elegante.
            </p>

            <h4 class="topics-subtitle">useMemo y useCallback</h4>
            <p class="topics-copy">
              Optimización de rendimiento con memoización:
            </p>
            <pre>
              <code class="language-jsx">
import { useState, useMemo, useCallback } from 'react';

function ListaOptimizada({ items }) {
  const [filtro, setFiltro] = useState('');
  
  // Memoiza el cálculo costoso
  const itemsFiltrados = useMemo(() =&gt; {
    return items.filter(item =&gt; 
      item.nombre.toLowerCase().includes(filtro.toLowerCase())
    );
  }, [items, filtro]);
  
  // Memoiza la función para evitar re-renders
  const manejarClick = useCallback((id) =&gt; {
    console.log('Item clickeado:', id);
  }, []);
  
  return (
    &lt;div&gt;
      &lt;input 
        value={filtro}
        onChange={(e) =&gt; setFiltro(e.target.value)}
        placeholder="Filtrar items..."
      /&gt;
      {itemsFiltrados.map(item =&gt; (
        &lt;Item 
          key={item.id} 
          item={item} 
          onClick={manejarClick}
        /&gt;
      ))}
    &lt;/div&gt;
  );
}
              </code>
            </pre>

            <h4 class="topics-subtitle">useRef y useImperativeHandle</h4>
            <p class="topics-copy">Referencias y control imperativo:</p>
            <pre>
              <code class="language-jsx">
import { useRef, useImperativeHandle, forwardRef } from 'react';

// Componente con ref personalizada
const InputPersonalizado = forwardRef((props, ref) =&gt; {
  const inputRef = useRef();
  
  useImperativeHandle(ref, () =&gt; ({
    focus: () =&gt; inputRef.current.focus(),
    clear: () =&gt; inputRef.current.value = '',
    getValue: () =&gt; inputRef.current.value
  }));
  
  return &lt;input ref={inputRef} {...props} /&gt;;
});

// Uso del componente
function Formulario() {
  const inputRef = useRef();
  
  const manejarEnvio = () =&gt; {
    console.log('Valor:', inputRef.current.getValue());
    inputRef.current.clear();
  };
  
  return (
    &lt;div&gt;
      &lt;InputPersonalizado ref={inputRef} placeholder="Escribe algo..." /&gt;
      &lt;button onClick={manejarEnvio}&gt;Enviar&lt;/button&gt;
    &lt;/div&gt;
  );
}
              </code>
            </pre>

            <h4 class="topics-subtitle">Opinión y Mejores Prácticas</h4>
            <p class="topics-copy">
              Los hooks avanzados son herramientas poderosas que requieren
              comprensión profunda de cuándo y cómo usarlos. No abuses de la
              optimización prematura; primero mide el rendimiento real antes de
              aplicar useMemo o useCallback. La clave está en entender el ciclo
              de vida de React y los casos de uso específicos.
            </p>
            <ul class="bullet-list">
              <li>Usa useMemo para cálculos costosos</li>
              <li>useCallback para funciones que se pasan como props</li>
              <li>useRef para referencias DOM y valores mutables</li>
              <li>Mide el rendimiento antes de optimizar</li>
              <li>Evita la optimización prematura</li>
            </ul>
          </div>
        </li>

        <li>
          <h2>
            <a
              class="topics-title topics-title--ready"
              href="javascript:void(0)"
            >
              Ciclo de Vida en React
            </a>
          </h2>
          <div class="topics-info">
            <h3 class="topics-subtitle">¿Qué es el Ciclo de Vida en React?</h3>
            <p class="topics-copy">
              El ciclo de vida en React describe las diferentes fases por las
              que pasa un componente desde su creación hasta su destrucción. Con
              la introducción de hooks, el manejo del ciclo de vida se ha
              simplificado, pero sigue siendo fundamental entender cuándo y cómo
              se ejecutan las diferentes fases.
            </p>

            <h4 class="topics-subtitle">
              useEffect - El Hook del Ciclo de Vida
            </h4>
            <p class="topics-copy">
              useEffect reemplaza los métodos de ciclo de vida de las clases:
            </p>
            <pre>
              <code class="language-jsx">
import { useState, useEffect } from 'react';

function UsuarioPerfil({ usuarioId }) {
  const [usuario, setUsuario] = useState(null);
  const [cargando, setCargando] = useState(true);
  
  // Equivalente a componentDidMount
  useEffect(() =&gt; {
    console.log('Componente montado');
    
    // Cargar datos del usuario
    fetch(`/api/usuarios/${usuarioId}`)
      .then(response =&gt; response.json())
      .then(data =&gt; {
        setUsuario(data);
        setCargando(false);
      });
  }, [usuarioId]); // Dependencias
  
  // Equivalente a componentDidUpdate
  useEffect(() =&gt; {
    if (usuario) {
      console.log('Usuario actualizado:', usuario.nombre);
    }
  }, [usuario]);
  
  // Equivalente a componentWillUnmount
  useEffect(() =&gt; {
    return () =&gt; {
      console.log('Componente desmontado');
      // Limpiar suscripciones, timers, etc.
    };
  }, []);
  
  if (cargando) return &lt;div&gt;Cargando...&lt;/div&gt;;
  
  return (
    &lt;div&gt;
      &lt;h1&gt;{usuario.nombre}&lt;/h1&gt;
      &lt;p&gt;{usuario.email}&lt;/p&gt;
    &lt;/div&gt;
  );
}
              </code>
            </pre>

            <h4 class="topics-subtitle">Fases del Ciclo de Vida</h4>
            <p class="topics-copy">Las principales fases del ciclo de vida:</p>
            <ul class="bullet-list">
              <li>
                <strong>Montaje:</strong> Componente se crea y se inserta en el
                DOM
              </li>
              <li>
                <strong>Actualización:</strong> Componente se re-renderiza por
                cambios
              </li>
              <li>
                <strong>Desmontaje:</strong> Componente se elimina del DOM
              </li>
              <li>
                <strong>Manejo de Errores:</strong> Captura errores en el árbol
                de componentes
              </li>
            </ul>

            <h4 class="topics-subtitle">Opinión y Mejores Prácticas</h4>
            <p class="topics-copy">
              El ciclo de vida moderno con hooks es más predecible y fácil de
              entender que los métodos de clase. La clave está en entender las
              dependencias de useEffect y cuándo usar cada variante. Siempre
              limpia los efectos secundarios para evitar memory leaks.
            </p>
            <ul class="bullet-list">
              <li>Usa useEffect para efectos secundarios</li>
              <li>Especifica dependencias correctamente</li>
              <li>Limpia suscripciones y timers</li>
              <li>Usa useLayoutEffect para mediciones DOM</li>
              <li>Considera useReducer para state complejo</li>
            </ul>
          </div>
        </li>

        <li>
          <h2>
            <a
              class="topics-title topics-title--ready"
              href="javascript:void(0)"
            >
              React Fiber Algorithm
            </a>
          </h2>
          <div class="topics-info">
            <h3 class="topics-subtitle">¿Qué es React Fiber?</h3>
            <p class="topics-copy">
              React Fiber es el algoritmo de reconciliación que React usa para
              determinar qué cambios necesita hacer en el DOM. Introducido en
              React 16, Fiber permite interrumpir el trabajo de renderizado para
              priorizar actualizaciones más importantes, mejorando
              significativamente el rendimiento y la experiencia de usuario.
            </p>

            <h4 class="topics-subtitle">Características de Fiber</h4>
            <p class="topics-copy">
              Las principales características del algoritmo Fiber:
            </p>
            <ul class="bullet-list">
              <li>
                <strong>Interrumpible:</strong> Puede pausar y reanudar el
                trabajo
              </li>
              <li>
                <strong>Priorizable:</strong> Asigna prioridades a diferentes
                tipos de actualizaciones
              </li>
              <li>
                <strong>Reutilizable:</strong> Puede reutilizar trabajo previo
              </li>
              <li>
                <strong>Incremental:</strong> Divide el trabajo en chunks
                pequeños
              </li>
            </ul>

            <h4 class="topics-subtitle">Fases del Renderizado</h4>
            <p class="topics-copy">
              Fiber divide el renderizado en dos fases principales:
            </p>
            <pre>
              <code class="language-jsx">
// Fase 1: Render/Reconciliación (interrumpible)
function Componente() {
  const [contador, setContador] = useState(0);
  
  // Esta fase puede ser interrumpida
  const elementos = (
    &lt;div&gt;
      &lt;h1&gt;Contador: {contador}&lt;/h1&gt;
      &lt;button onClick={() =&gt; setContador(c =&gt; c + 1)}&gt;
        Incrementar
      &lt;/button&gt;
    &lt;/div&gt;
  );
  
  return elementos;
}

// Fase 2: Commit (no interrumpible)
// Aquí se aplican los cambios al DOM
              </code>
            </pre>

            <h4 class="topics-subtitle">Beneficios del Fiber</h4>
            <p class="topics-copy">
              Los principales beneficios del algoritmo Fiber:
            </p>
            <ul class="bullet-list">
              <li>
                <strong>Mejor rendimiento:</strong> Evita bloqueos del hilo
                principal
              </li>
              <li>
                <strong>Priorización:</strong> Actualizaciones urgentes se
                procesan primero
              </li>
              <li>
                <strong>Concurrent Mode:</strong> Permite renderizado
                concurrente
              </li>
              <li>
                <strong>Suspense:</strong> Manejo elegante de carga asíncrona
              </li>
            </ul>

            <h4 class="topics-subtitle">Opinión y Mejores Prácticas</h4>
            <p class="topics-copy">
              React Fiber representa una evolución fundamental en cómo React
              maneja el renderizado. Aunque es transparente para la mayoría de
              desarrolladores, entender sus conceptos ayuda a escribir código
              más eficiente. La clave está en aprovechar las características
              concurrentes y mantener componentes puros.
            </p>
            <ul class="bullet-list">
              <li>Mantén componentes puros y predecibles</li>
              <li>Usa React.memo para optimización</li>
              <li>Aprovecha Suspense para carga asíncrona</li>
              <li>Considera Concurrent Mode para apps complejas</li>
              <li>Monitorea el rendimiento con React DevTools</li>
            </ul>
          </div>
        </li>
      </ol>
    </section>

    <section class="quiz-container">
      <p>Mide cuanto realmente aprendiste:</p>
      <a class="quiz" href="./quiz/index.html">
        <span class="quiz-icon">🧠</span>
        Quiz Time!
      </a>
    </section>

    <footer>
      <p>
        Diseñado y codeado por <br />
        <strong>
          <a href="https://gsvidal.github.io" target="_blank" rel="noopener">
            Gonzalo Vidal
          </a>
        </strong>
        <br />
        Puedes encontrarme en estas plataformas:
      </p>
      <div class="contact">
        <a href="https://gsvidal.github.io" target="_blank" rel="noopener"
          ><img
            src="https://i.postimg.cc/WbLs5F6b/MIYMC01.gif"
            alt="Portafolio de Proyectos Web"
            width="45px"
            height="45px"
        /></a>
        <a href="https://github.com/gsvidal" target="_blank" rel="noopener"
          ><img
            src="https://i.postimg.cc/ncDt7Hyb/github.png"
            width="45px"
            height="45px"
            alt="Cuenta de GitHub: gsvidal"
        /></a>
        <a
          href="https://www.linkedin.com/in/gsvidal/"
          target="_blank"
          rel="noopener"
          ><img
            src="https://i.postimg.cc/P5bs3SfS/linkedin.png"
            width="45px"
            height="45px"
            alt="Cuenta de Linkedin"
        /></a>
        <a href="https://bio.torre.co/es/gsvidal" target="_blank" rel="noopener"
          ><img
            src="https://i.postimg.cc/VkPPWxwS/torre.png"
            width="45px"
            height="45px"
            alt="Cuenta de Torre"
        /></a>
        <a
          href="https://www.instagram.com/gsvidal.web/"
          target="_blank"
          rel="noopener"
          ><img
            src="https://i.postimg.cc/PqtGB1PT/instagram.png"
            width="45px"
            height="45px"
            alt="Cuenta de Instagram: @gsvidal.web"
        /></a>
      </div>
    </footer>
    <!-- Hacer preguntas al final de cada artículo, para probar los conocimientos -->
  </body>

  <script src="./blog.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
</html>
