<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="5 Fundamentos que todo desarrollador Front-End debe dominar">
  <meta name="robots" content="index, follow">
  <title>5 Fundamentos Front-End</title>
  <link rel="stylesheet" href="./css/estilos.css">
  <link rel="stylesheet" href="./prism.css">
  <link rel="icon" type="image/png" sizes="16x16" href="https://i.imgur.com/k4a0ecv.png">
  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css2?family=PT+Serif:wght@400;700&family=Poppins:wght@200;300;400;700&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Courier+Prime&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Oxygen:wght@300;400;700&display=swap" rel="stylesheet">
</head>

<body>
  <section class="construction">
    <p> <strong>En construcción</strong><br>Inicio: 09/01/2021 <br> Estreno-aprox: 15/02/2021 <br> % Avance: </p>
    <div class="capacidad_barra">
      <div class="capacidad_barra_full">
      </div>
    </div>
  </section>
  <header>
    <h1 class="blog-title">5 Fundamentos que todo desarrollador Front-End debe dominar
    </h1>
    <section class="blog-title__container">
    <p class="blog-title__description">
      Existen muchas y muchos desarrolladores con experiencia en esta industria, los cuales a lo largo de los años han logrado abrirse paso en medio de este mar de tecnologías, lenguajes y frameworks del mundo de la programación y lo han hecho bien hasta ahora, pero una parte de ellos(y no una insignificante) aún siente que mucho de esto funciona como una suerte de <i>Arte de Magia</i>, lo cual desde un punto de vista <i>holístico</i>, como el de la <strong>Ingeniería de Software</strong>, no es lo ideal. 
    </p>
    <p class="blog-title__description">
      El conocer respuestas a interrogantes tales como: <strong>"¿Qué es y como funciona el motor de JavaScript?"</strong>, <strong>"¿Como crear y en que puedo utilizar cierta Estructura de Datos?"</strong> o <strong>"¿Cómo funciona el asincronismo en JavaScript?"</strong>, entre otras, puede llevarte al siguiente nivel.
    </p>  
    <p class="blog-title__description">
      En las siguientes líneas encontrarás temas que puedes haber oído, quizás solo superficialmente, pero es momento de cambiar eso. Aquí inicia este artículo de los <i>5 Fundamentos que todo desarrollador Front-End debe dominar.</i> <br>
    </p>
    </section>
  </header>
  
  <section class = "topics-container" id = "topics-container-JS">
    <ol class="numeracion-orden-principal">
      <li>
        <h2><a class="topics-title topics-title-ready" href="javascript:void(0)">
          Estructuras de Datos
        <p class="new">Nuevo!</p>
      </a></h2>

        <div class= "topics-info">
          <p>
            Según Wikipedia una <a class="enlaces-externos" href="https://es.wikipedia.org/wiki/Estructura_de_datos">estructura de datos</a> es una forma particular de organizar datos en una computadora para que puedan ser utilizados de manera eficiente. <br><br>
            También podemos definirla como una forma de organizar datos.
            Comprenden colecciones de valores, las relaciones entre ellos y las funciones y operaciones que se les puedan aplicar. <br><br>
            El uso "eficiente" que se le dará dependerá del motivo a necesitar cierta estructura de datos. Quizás necesitemos una estructura donde se requiere una búsqueda rápida de elementos, o una inserción eficiente, etc, todo dependerá de que aplicación estemos haciendo. <br><br>
            Aquí entra un tema importante: la <strong>complejidad.</strong> 
            <h3>La Complejidad</h3>
            Este término hace referencia a como se expresan las ventajas y desventajas que tiene cada estructura de datos al utilizarse en un problema en particular.
            La complejidad se puede expresar en 2 ejes: El <strong>espacio</strong> y el <strong>tiempo</strong>.
            <h4>El espacio</h4>
            La <strong>complejidad del espacio</strong> representa el consumo de memoria de una estructura de datos.
            <h4>El tiempo</h4>
            La <strong>complejidad del tiempo</strong> se necesita expresar para varias operaciones que se puede usar en estructuras de datos, tales como insertar(agregar), eliminar, buscar y/ o acceder elementos. <br>
            <figure>
              <img class="infografia" src="https://i.postimg.cc/1tBszKCD/GSVIDAL-WEB-6.png" alt="Infografía de tipos de estructuras de datos">
              <figcaption>Principales tipos de Estructuras de Datos</figcaption>
            </figure>

            
            <br>
            Podemos agrupar estas estructuras en 3 diferentes tipos: <br><br>
            <ol>
              <li class="elem-lista-numerada">
              Las estructuras del <i>tipo-Array</i>, como los <strong>Arrays</strong>, <strong>Stacks</strong> y <strong>Queues</strong> las cuales se diferencian principalmente en la forma de insertar y remover elementos de ellas.
              </li> 
              <li class="elem-lista-numerada">
                Las <strong>Hash Tables</strong> dependen de <i>hash functions</i>  para localizar y guardar información.
                </li> 
              <li class="elem-lista-numerada">
                <strong>Linked Lists</strong>, <strong>Trees</strong> y <strong>Graphs</strong> son estructuras con <i>nodos</i>  que guardan referencias con otros nodos.
              </li> 
              
            </ol>   
          
          ¿Quieres ver el código .js de todas estas estructuras de datos?. Puedes encontrarlo en GitHub en el repositorio <a class="enlaces-externos" href="https://github.com/gsvidal/DataStructures-JS/tree/master" target="_blank">Data Structures-JS</a>

          <h3 class='topics-subtitle'>Arrays</h3>  
          Los Arrays(arreglos) son una colección de elementos, los cuales son emparejados con un key(índice), la forma más básica de esta estructura es el array lineal(array unidimensional).
          <br><br>
          Los arrays son una de las estructuras más antiguas e importantes, así como de las más utilizadas en casi toda aplicación.
          <br><br>
          Creo que todos hemos utilizado un array en JavaScript, tan solo inicializándolo así:
          
          <pre>
            <code class="language-js">
var array1 = [1,3,4,5,7];
            </code>
          </pre>

          Pero ya que estamos en el fundamento de: <i>Estructura de Datos</i>, vamos a crear una clase MyArray y en ella, crear métodos para buscar, agregar, remover valores del array. En pocas palabras veremos como crear desde cero métodos similares a los <i>built-in methods</i> .push(), .pop(), unshift(), .shift(), etc.
          <br>
          <pre>
            <code class="language-js">
 class MyArray { 
   constructor() {
     this.length = 0;
     this.data = {};
   }
 }              
            </code>
          </pre>
          
          Luego instanciaremos la clase MyArray:
          <br>
          <pre>

          <code class="language-js">
myArray = new MyArray();
          </code>
          </pre>
          
          *Podemos utilizar el Inspector de elementos para trabajar esto, lo que nos da el siguiente output:
          <pre>
            <code class="language-js">
              <output>
//MyArray {length: 0, data: {…}}
              </output>
            </code>
          </pre>
          Como vemos esa estructura está vacía, tiene un lenght de 0 y no contiene data. <br><br>
          Ahora creemos unos cuantos <strong>métodos</strong> para poder hacer operaciones sobre nuestro array. Los crearemos dentro de nuestra clase MyArray, previamente creada:<br>

          <pre>
            <code class="language-js">

 class MyArray {
   constructor() {
     this.length = 0;
     this.data = {};
   }
   //Nuestro método get devuelve el valor del elemento con índice index
   get(index) {
     return this.data[index];
   }
   //Nuestro método push añade un valor al final del array
   push(item) {
     this.data[this.length] = item;
     this.length++;
     return this.data;
   }
   //Nuestro método pop remueve el último elemento del array
   pop() {
     const lastItem = this.data[this.length - 1];
     delete this.data[this.length -1];
     this.length--;
   }
   //Nuestro método delete elimina el elemento de indice index y devuelve el elemento removido.
   delete(index) {
     const item = this.data[index];
     this.shiftIndex(index);
     return item;
   }
   shiftIndex(index) {
     for(let i = index; i < this.length - 1; i++) {
       this.data[i] = this.data[i + 1];
     }
     delete this.data[this.length - 1];
     this.length--;
   }
   //Nuestro método unshiftItem añade un elemento(item) al inicio de nuestro array y devuelve la longitud del array
   unshiftItem(item) {
     this.length++;
     this.unshiftIndex();
     this.data[0] = item;
     
     return this.length;
   }
   unshiftIndex() {
     for(let i = this.length - 1; i > 0 ; i--) {
       this.data[i] = this.data[i-1];
     }
   }
   //Para nuestro método shiftItem vamos a remover el primer elemento de nuestro array, usaremos el método delete() creado anteriormente.
   shiftItem() {
     return this.delete(0);
   }
 }
              </code>
          </pre>

          <h3 class='topics-subtitle'>Stacks</h3> 

          Los <strong>stacks</strong>(pilas) son también una colección de elementos, están apilados y cuenta con 3 operaciones principales, peek(), push() y pop(), la forma en que se añaden y remueven elementos es a través del ordenamiento LIFO(Last in, first out), es decir el último que entra es el primero que sale.
          Un ejemplo práctico y conocido de un stack es el call stack. 
          <figure>
            <img class="infografia infografia-chica" src="https://i.postimg.cc/sfWVc0PQ/GSVIDAL-WEB-14.jpg.jpg" alt="Imagen de un stack">
            <figcaption>Diagrama de un stack</figcaption>
          </figure>
          Ahora pasemos a lo interesante, crearemos un stack usando clases como en el caso del array. <br>
          Pero antes de eso expliquemos el concepto de <i>nodos</i>, que utilizaremos a lo largo del tema de estructura de datos, y si bien mencionamos que los Linked Lists, Trees y Graphs son estructuras basadas en nodos, también podemos tratar a cada elemento del stack(y más adelante al queue), como un nodo que tiene un valor(value) y que tiene una referencia a través de un puntero al siguiente elemento(el próximo en entrar).
          
          <pre>
            <code class="language-js">
 //Creamos una clase Node(nodo) para no repetir código en los métodos
 class Node {
   constructor(value) {
     this.value = value;
     this.next = null;
   }
 }

class Stack {
  constructor() {
    this.top = null;
    this.bottom = null;
    this.length = 0;
  }
  //Nuestro método peek nos devuelve el elemento top(último en ingresar)
  peek() {
    return this.top;
  }
  //Nuestro método push agrega un elemento al (top) del stack y nos devuelve el stack
  push(value) {
    const newNode = new Node(value);
    if(this.length === 0) {
      this.top = newNode;
      this.bottom = this.top;
    } else {
      const holdingPointer = newNode;
      this.top.next = holdingPointer;
      this.top = holdingPointer;
    }
    this.length++;

    return this;
  }
  //Nuestro método pop remueve el elemento top y nos devuelve el stack
  pop() {
    var penultimo = myStack.bottom;
    for(let i = 0; i < this.length-2; i++) {
      penultimo = penultimo.next;
    }

    this.top = penultimo;
    this.top.next = null;
    this.length--;

    return this;
  }
}
//Instanciamos la clase Stack
const myStack = new Stack();
            </code>
          </pre>

          <h3 class='topics-subtitle'>Queues</h3> 

          Los <strong>queues</strong> son <i>colas</i>, sus operaciones principales son agregar elementos al final de la cola(enqueue) y remover el primer elemento de la cola (dequeue), usa el protocolo FIFO (First in First Out), lo que significa que el primero que entra a la cola, es el primero que sale al remover un elemento.
          <figure>
            <img class="infografia infografia-chica" src="https://i.postimg.cc/SxkNj7MX/GSVIDAL-WEB-15.jpg" alt="Imagen de un queue">
            <figcaption>Diagrama de un Queue</figcaption>
          </figure>
          Veamos el código:
          <pre>
            <code class="language-js">
//Creamos una clase Node(nodo) para no repetir código en los métodos
class Node {
  constructor(value) {
    this.value = value;
    this.next = null;
  }
}

class Queue {
  constructor() {
    this.first = null;
    this.last = null;
    this.length = 0;
  }
  //Nuestro método peek nos devuelve el elemento first(primero en la cola)
  peek() {
    return this.first;
  }
  //Con nuestro método enqueue agregaremos un elemento al final de la cola (last)
  enqueue(value) {
    const newNode = new Node(value);
    if(this.length === 0) {
      this.first = newNode;
      this.last = newNode;
    } else {
      this.last.next = newNode;
      this.last = newNode;
    }
    this.length++;

    return this;
  }
  //Con nuestro método dequeue removeremos el primer elemento de la cola
  dequeue() {
    if(this.length !== 0) {
    const second = myQueue.first.next;
    this.first = second;
    this.length--;

    return this;
    } else {
      console.log("Queue is empty, you cannot dequeue!")
    }
  }
  
}
//Instanciamos la clase Queue
const myQueue = new Queue();

            </code>
          </pre>

          <h3 class='topics-subtitle'>Hash Tables</h3> 

          Un <strong>Hash Table</strong> es una estructura de datos usada para implementar un array asociativo, donde se puede emparejar <i>keys</i> y <i>values</i>. Es similar a un objeto de JavaScript, con la diferencia que la hash table tiene un <strong>Hash Function</strong> que determina en que lugar de la memoria se ubicarán estos datos. Esta Hash Function recibe como argumento al key y retorna la dirección(address) de la locación en donde estará esta información. Pueden existir <i>colisiones</i>, lo que significa que puede haber dos keys diferentes para un mismo address, pero con el método set que veremos más adelante al enviar como parámetro al key, nos devolverá su value respectivo.
          <figure>
            <img class="infografia" src="https://i.postimg.cc/k4K8ygYB/GSVIDAL-WEB-13.jpg" alt="Imagen de un hash table">
            <figcaption>Diagrama de Hash Table</figcaption>
          </figure>

          <pre>
            <code class="language-js">
 class HashTable {
   constructor(size) {
     this.data = new Array(size);
   }
   //Lo siguiente es un Hash Function que fue creado arbitrariamente,existen muchos Hash Functions en GitHub
   hashMethod(key) {
    let hash = 0;
    for (let i = 0; i < key.length; i++) {
      hash = (hash + key.charCodeAt(i) * i) % this.data.length;
    }
    return hash;
   }
   //El metodo set nos inserta un elemento con su key y value(puede haber colisiones)
   set(key, value) {
    const address = this.hashMethod(key);
    if (!this.data[address]) {
      this.data[address] = [];
    }
    this.data[address].push([key, value]);
    return this.data;
   }
   //El metodo get nos devuelve el valor que le corresponde al key, en caso no exista el key enviado nos devolverá undefined
   get(key) {
    const address = this.hashMethod(key);
    const currentBucket = this.data[address];
    if (currentBucket) {
      for (let i = 0; i < currentBucket.length; i++) {
        if (currentBucket[i][0] === key) {
          return currentBucket[i][1];
        }
      }
    }
    return undefined;
   }
 }     
 //Instanciamos el HashTable con 50 espacios libres
 const myHashTable = new HashTable(50);  

            </code>
          </pre>
            

          <h3 class='topics-subtitle'>Linked Lists</h3> 

          Los <strong>Linked Lists</strong> almacenan data en forma secuencial, pero en lugar de mantener índices, mantienen <i>pointers(punteros)</i> a otros elementos.
          El primer nodo es llamado <strong>head</strong> y el último nodo <strong>tail</strong>. <br><br>
          Existen dos tipos de linked list:
          <ol>
            <li>
              <strong>Singly Linked List:</strong>  <br>
              Cada nodo tiene solo un puntero hacia el siguiente nodo <i>(next)</i>.
            </li>
            <li>
              <strong>Doubly Linked List:</strong>  <br>
              En este caso además del <i>next</i>, cada nodo tiene un puntero adicional hacia el nodo previo(prev).
            </li>
          </ol>
          <br>
          <figure class="infografias-container">
           <div>
            <img class="infografias" src="https://i.postimg.cc/GhBvqR7P/GSVIDAL-WEB-16.jpg" alt="Imagen de Singly Linked List">
            <figcaption>Diagrama de un Singly Linked List</figcaption>
           </div>
           <div>
            <img class="infografias" src="https://i.postimg.cc/R0TtNZhm/GSVIDAL-WEB-17.jpg" alt="Imagen de Doubly Linked List">
            <figcaption>Diagrama de un Doubly Linked List</figcaption>
           </div>
          </figure>
          Démosle un vistazo al código: <br>
          <strong>Singly Linked List:</strong>
          <pre>
            <code class="language-js">
//Creamos una clase Node(nodo) para no repetir código en los métodos
 class Node {
   constructor(value) {
     this.value = value;
     this.next = null;
   }
 }
 
 class MySinglyLinkedList {
   constructor(value) {
     this.head = {
       value: value,
       next: null
     }
     this.tail = this.head;
     this.length = 1;
   }
   //Nuestro método append agregará un elemento al final(tail) del Singly Linked List
   append(value) {
     const newNode = new Node(value);
     this.tail.next = newNode;
     this.tail = newNode;
     this.length++;
 
     return this;
   }
   //Nuestro método prepend agregará un elemento al inicio(head) del Singly Linked List
   prepend(value) {
     const newNode = new Node(value);
     newNode.next = this.head;
     this.head = newNode;
 
     this.length++;
   }
   //Nuestro método insert insertará un elemento con índice index en el Singly Linked List
   insert(index, value) {
     if(index >= this.length) {
       console.log("No hay suficientes elementos, será enviado al final");
       return this.append(value);
     }
 
     const newNode = new Node(value); 
     const firstPointer = this.getTheIndex(index - 1);
     //Se crea una const holdingPointer que servirá para no perder el puntero next del firstPointer.
     const holdingPointer = firstPointer.next;
     firstPointer.next = newNode;
     newNode.next = holdingPointer;
 
     this.length++;
 
     return this;
   }
 
   getTheIndex(index) {
     let currentNode = this.head;
 
     for(let counter = 0; counter < this.length; counter++) {
       if(counter !== index) {
         currentNode = currentNode.next;
       } else{
         return currentNode;
       }
     }
   }
 }
 //Instanciando MySinglyLinkedList:
 let myLinkedList = new MySinglyLinkedList(1;              
            </code>
          </pre>

          <strong>Doubly Linked List:</strong>
          <pre>
            <code class="language-js">
//Como podremos ver el código para el doubly linked list solo se diferencia por ser unas cuantas líneas más larga:

class Node {
  constructor(value) {
    this.value = value;
    this.next = null;
    this.prev = null;
  }
}
 
class MyDoublyLinkedList {
  constructor(value) {
    this.head = {
      value: value,
      next: null,
      // Doubly: se añade la siguiente linea
      prev: null,
    };
    this.tail = this.head;
 
    this.length = 1;
  }
  append(value) {
    const newNode = new Node(value);
    newNode.prev = this.tail;
    this.tail.next = newNode;
    this.tail = newNode;
    this.length++;
 
    return this;
  }
  prepend(value) {
    const newNode = new Node(value);
    // Doubly: se añade la siguiente linea
    this.head.prev = newNode;
    
    newNode.next = this.head;
    this.head = newNode;
 
    this.length++;
  }
  insert(index, value) {
    if(index >= this.length) {
      console.log("No hay suficientes elementos, será enviado al final");
      return this.append(value);
    }
 
    const newNode = new Node(value);
    let firstPointer = this.getTheIndex(index - 1);
    let secondPointer = this.getTheIndex(index);
    let holdingPointer = firstPointer.next;
    firstPointer.next = newNode;
    newNode.next = holdingPointer;
    // Doubly: se añaden las siguientes 3 líneas
    holdingPointer.prev = newNode;
    firstPointer = newNode.prev;
    holdingPointer = secondPointer;
 
    this.length++;
 
    return this;
 
  }
 
  getTheIndex(index) {
    
    let currentNode = this.head;
 
    for(let counter = 0; counter < this.length; counter++) {
      if(counter !== index) {
        currentNode = currentNode.next;
      } else{
        return currentNode;
      }
    }
  }
  
}
//Instanciando MyDoublyLinkedList:
let myDoublyLinkedList = new MyDoublyLinkedList(1);              
            </code>
          </pre>

          <h3 class='topics-subtitle'>Trees</h3> 

          Una estructura de datos en forma de árbol o <strong>Tree</strong> simula una estructura de árbol jerárquica, con un nodo padre, un valor root e hijos(children). Cada nodo contiene un valor y una referencia a su(s) hijo(s). <br><br>
          En este caso veremos un Binary Search Tree, un tipo de Tree usado para insertar y buscar valores en la estructura.
          Un Binary Searh Tree consta de un root donde a partir de este elemento se inicia la búsqueda, cada elemento solo puede tener dos descendientes(children), los <i>children</i> que son mayores que el elemento padre se colocan debajo del padre pero al lado derecho y los menores al lado izquierdo. <br><br>
          
          <figure class="infografias-container">
            <div>
             <img class="infografias" src="https://i.postimg.cc/ZKk8gb16/GSVIDAL-WEB-18.jpg" alt="Imagen de un Tree">
             <figcaption>Diagrama de un Tree</figcaption>
            </div>
            <div>
             <img class="infografias" src="https://i.postimg.cc/598YXwRF/GSVIDAL-WEB-19.jpg" alt="Imagen de un Binary Search Tree">
             <figcaption>Diagrama de un Binary Search Tree</figcaption>
            </div>
           </figure>

           Ahora sí, para este código, armaremos el binary search tree de arriba.

           <pre>
             <code class="language-js">         
  class Node {
    constructor(value) {
      this.left = null;
      this.right = null;
      this.value = value;
    }
  }
  
  class BinarySearchTree {
    constructor() {
      this.root = null;
    }
    //Con este método insert, podremos agregar nodos con sus valores y referencias según la condición si son menor o mayor al padre.
    insert(value) {
      const newNode = new Node(value);
      if(this.root === null) {
        this.root = newNode;
      } else {
        let currentNode = this.root;
        while(true) {
          if(value < currentNode.value) {
            if(!currentNode.left) {
              currentNode.left = newNode;
              return this;
            }
            currentNode = currentNode.left;
          } else {
            if(!currentNode.right) {
              currentNode.right = newNode;
              return this;
            }
            currentNode = currentNode.right;
          }
        } 
      }
    }
    //El método search nos permitirá devolver el nodo en el que se encuentra el valor(value) enviado como argumento. Recordar que el nodo es el conjunto de información como: value, left child, right child. En caso de recorrerse el binary search tree y no encontrar el valor buscado nos indicará que no existe el valor.
    search(value) {
      var msj = "no se encuentra el valor";
      if(this.root === null) {
        console.log(`The tree is empty!`);
      } else {
        let currentNode = this.root;
         while(true) {
          if(value === currentNode.value) {
            return currentNode;
          } else {
            if(value < currentNode.value) {
              if(currentNode.left) {
                currentNode = currentNode.left;
              } else {
                return msj;
              }
            } else {
              if(currentNode.right) {
                currentNode = currentNode.right;
              } else {
                return msj;
              }
            }
          }
          
         }
        } 
    }   
  }
  //Instanciamos BinarySearchTree
  const myBinarySearchTree = new BinarySearchTree();
             </code>
           </pre>

          <h3 class='topics-subtitle'>Graphs</h3> 
          
          Los grafos o <strong>Graphs</strong> consisten en una colección finita de vertices(nodos) unidos por bordes(edges), existen varios tipos de grafos, según diferentes criterios: <br><br>  
          <figure class="infografias-container">
            <div>
             <img class="infografias" id="infografias-graph" src="https://i.postimg.cc/x1vCj6wq/GSVIDAL-WEB-20.jpg" alt="Diagrama de un Graph">
             <figcaption>Diagrama de un Graph</figcaption>
            </div>
            <div>
             <img class="infografias" src="https://i.postimg.cc/xCLrSZJ1/GSVIDAL-WEB-21.jpg" alt="Tipos de Graph: Ponderado y no ponderado">
             <figcaption>Tipos de Graph: Ponderado y no ponderado</figcaption>
            </div>
           </figure>
           <figure class="infografias-container">
            <div>
             <img class="infografias" src="https://i.postimg.cc/gjfmM2Kj/GSVIDAL-WEB-24.jpg" alt="Tipos de Graph: Cíclico y acíclico">
             <figcaption>Tipos de Graph: Cíclico y acíclico</figcaption>
            </div>
            <div>
             <img class="infografias" src="https://i.postimg.cc/52DkN3MY/GSVIDAL-WEB-23.jpg" alt="Tipos de Graph: Dirigido y no dirigido">
             <figcaption>Tipos de Graph: Dirigido y no dirigido</figcaption>
            </div>
           </figure>
           Existen varias maneras de representar un grafo, pero 2 de las principales son: <br><br>
           <ol>
            <li>
              <strong>Lista de Adyacencia:</strong>  <br>
              Para cada vértice, se almacena una lista de vértices adyacentes.
            </li>
            <li>
              <strong>Matriz de Adyacencia:</strong>  <br>
              La información es almacenada en una matriz bidimensional, en la cual las filas representan los vértices y las columnas representan los vértices a donde apuntan, la información en los bordes y vértices deben almacenarse externamente.
              <br><br>

            </li>
           </ol>

           Para el código usaremos la representación  con lista adjacente, del tipo no dirigido, y usaremos la forma y nodos del grafo de la imagen: <a class="enlaces-externos" href="#infografias-graph">Diagrama de un Graph.</a>

           <pre>
             <code class="language-js">
 class Graph {
   constructor() {
     this.nodes = 0;
     this.adjacentList = {};
   }
   //Se agregan nodos(vértices)
   addVertex(node) {
     this.adjacentList[node] = [];
     this.nodes++;
   }
   //Se agregan bordes(edges) pasando como argumentos a nodos(nodo1 y nodo2), el grafo del ejercicio es del tipo no dirigido, así que debe colocarse el método push en ambas direcciones.
   addEdge(node1, node2) {
     this.adjacentList[node1].push(node2);
     this.adjacentList[node2].push(node1);
   }
 }
 
 const myGraph = new Graph();
 
 //Creamos los vértices(nodos):
 myGraph.addVertex(1);
 myGraph.addVertex(3);
 myGraph.addVertex(4);
 myGraph.addVertex(5);
 myGraph.addVertex(6);
 myGraph.addVertex(8);
 
 //Creamos los Edges(bordes), ya que hay 7 bordes en el gráfico, deben haber 7 addEdge:
 myGraph.addEdge(8,4);
 myGraph.addEdge(4,5);
 myGraph.addEdge(4,1);
 myGraph.addEdge(1,6);
 myGraph.addEdge(3,6);
 myGraph.addEdge(1,3);
 myGraph.addEdge(5,3);   
             </code>
           </pre>

           Comparemos el output luego de ingresar el código: <br><br>
           <figure class="infografias-container">
            <div>
             <img class="infografias" id="infografias-graph" src="https://i.postimg.cc/x1vCj6wq/GSVIDAL-WEB-20.jpg" alt="Grafo a construir">
             <figcaption>Grafo a construir</figcaption>
            </div>
            <div>
             <img class="infografias" src="https://i.postimg.cc/cHPPF9w0/myGraph.jpg" alt="Output en Inspector de Elementos-Consola">
             <figcaption>Output en el Inspector de Elementos-Consola</figcaption>
            </div>
           </figure>

           Como vemos en el output, al llamar a <i>myGraph</i> en su adjacentList nos muestra los nodos y sus respectivos nodos unidos por bordes, por ejemplo el nodo 1 tiene como nodos adyacentes(unidos por un borde) a los nodos 4,6 y 3. Lo cual es rápidamente verificable viendo el diagrama del grafo <br><br>

           <h3>Conclusiones</h3>

           Existen muchas más estructuras de datos las cuales responden de una mejor o no tan eficiente manera al uso que se les quiera dar, algunas resaltan por su eficiencia en tiempo de búsqueda, otras por la forma de insertar o remover elementos, aquí entra en juego la habilidad y experiencia del desarrollador/ingeniero para saber cuando y por qué usar una estructura de datos en particular. <br><br>

           Las formas de crear las estructuras de datos de este artículo es una de tantas maneras de llegar al mismo resultado o similar, esta vez se usó clases, pero también se puede crear con funciones. <br><br>
          </p>
        </div>  
      </li>

      <li>
        <h2><a class="topics-title" href="javascript:void(0)">
          Motores de JavaScript
        <p class="coming-soon">Próximamente</p>
      </a></h2>
        <div class= "topics-info">
          <p>
            Como desarrolladores web, es bueno conocer los fundamentos del lenguaje Javascript y de su motor, este último con el fin de comprender como a partir de un lenguaje que los humanos podemos entender, se llega a convertir en algo que las maquinas pueden entender.
          <h3 class='topics-subtitle'>Diferentes Motores de Javascript</h3>  
          Cada navegador tiene su propio motor de javascript, entre los más conocidos tenemos a:
          </p>
        </div>  
      </li>

      <li>
        <h2><a class="topics-title" href="javascript:void(0)">
          Objetos
        <p class="coming-soon">Próximamente</p>
      </a></h2>
        <div class= "topics-info">
          <p>
          Los objetos son...
          </p>
        </div>  
      </li>

      <li>
        <h2><a class="topics-title" href="javascript:void(0)">
          Métodos en JavaScript
        <p class="coming-soon">Próximamente</p>
      </a></h2>
        <div class= "topics-info">
          <p>
          Los métodos  son...
          </p>
        </div>  
      </li>

      <li>
        <h2><a class="topics-title" href="javascript:void(0)">
          Asincronismo
        <p class="coming-soon">Próximamente</p>
      </a></h2>
        <div class= "topics-info">
          <p>
          El Asincronismo es...
          </p>
        </div>  
      </li>

    </ol>
  </section>

  <section class = "topics-container" id = "topics-container-HTML">
    <ol class="numeracion-orden-principal">
      <li>
        <h2><a class="topics-title" href="javascript:void(0)">
          Anatomía de una etiqueta HTML
        <p class="coming-soon">Próximamente</p>
      </a></h2>
        <div class= "topics-info">
          <p>
          Conocer la anatomía de las etiquetas HTML te dará muchas ventajas al ...
          <img class='' src='' width='30%'>
          </img>
          </p>
        </div>  
      </li>

      <li>
        <h2><a class="topics-title" href="javascript:void(0)">
          Etiquetas
        <p class="coming-soon">Próximamente</p>
      </a></h2>
        <div class= "topics-info">
          <p>
          Entre las etiquetas HTML más conocidas tenemos a:
          </p>
        </div>  
      </li>

    </ol>
  </section>

  <section class = "topics-container" id = "topics-container-CSS">
    <ol class="numeracion-orden-principal">
      <li>
        <h2><a class="topics-title" href="javascript:void(0)">
          Anatomía de una Regla CSS
        <p class="coming-soon">Próximamente</p>
      </a></h2>
        <div class= "topics-info">
          <p>
          Las Reglas, así como las etiquetas en HTML, son los ladrillos sobre los que se construyen las aplicaciones, paginas y sitios webs.
          <img class='' src='' width='30%'>
          </img>
          </p>
        </div>  
      </li>

      <li>
        <h2><a class="topics-title topics-title-ready" href="javascript:void(0)">
          Metodología BEM
        <p class="new">Nuevo</p>
      </a></h2>
        <div class= "topics-info">
          <p>
          Existen varias metodologías o convenciones para nombrar a las classes en CSS. Entre las principales tenemos a BEM, OOCSS, SMACSS, SUITCSS, etc. <br><br>
          Estas se utilizan para organizar nuestro código en CSS y ayuda a mantener CSSs extensos.
          <h4>¿Qué es BEM?</h4>
          BEM es una convención o standard para nombrar clases en CSS.
          <h4>¿Porqué utilizar BEM?</h4>
          Primero veamos por qué utilizarlo sobre las otras metodologías mencionadas líneas arriba, es menos confusa que otros métodos (SMACSS) pero aun nos brinda una buena arquitectura(OOCSS) y con una terminología que podemos reconocer.
          <br><br>
          Podemos encontrar <strong>3 beneficios</strong> al utilizar BEM:
          <ol>
            <li>Comunica propósito o función.</li>
            <li>Comunica estructura de compentes.</li>
            <li>Proporciona una especificidad baja.</li>
          </ol>

          <br> <strong>BEM</strong> significa: <br>
          <h4>Blocks</h4>
          <ol>
            <li>Los bloques son contenedores o el contexto donde están situados los elementos.</li>
            <li>Suelen ser etiquetas semánticas. ejem: (main, section, header, footer, etc.)</li>
            <li>Son independientes de otros bloques/elementos.</li>
          </ol>
          <br>
          Código en CSS:
          <pre>
            <code class="language-css">
.block {

}
            </code>
          </pre>
          Ejemplo:
          <pre>
            <code class="language-css">
.header {

}
            </code>
          </pre>

          <h4>Elements</h4>
          <ol>
            <li>Los elementos son parte de un bloque y no tienen significado semántico fuera de ese bloque.
            </li>
            <li>Los elementos son escritos usando el nombre del bloque conectado por dos guiones abajo (underscore) a ellos.</li>
          </ol>
          Código en CSS:
          <pre>
            <code class="language-css">
.block__element {

}
            </code>
          </pre>
          Ejemplo:
          <pre>
            <code class="language-css">
.header__navbar {

}
            </code>
          </pre>

          <h4>Modifiers</h4>
          <ol>
            <li>Los modificadores son un <i>flag</i> en un bloque o un elemento, se usa para cambiar apariencia, comportamiento  o estado.
            </li>
            <li>Ofrecen una gran ventaja: <i>Modularidad</i>.</li>
            <li>Al usar modificadores se facilita la <i>reutilización de código</i> e incentiva a la <i>programación por componentes</i>.</li>
            <br>
          </ol>
          
          <div class="modifiers-code-division">
            
            <div class="modifiers-left">
              Codigo en CSS(Modificador de un bloque):
              <pre>
                <code class="language-css">
    .block--modifier {
    
    }
                </code>
              </pre>
              ó Modificador de un elemento:
              <pre>
                <code class="language-css">
    .block__element--modifier {
    
    }
                </code>
              </pre>
            Ejemplo práctico: <br>
            CSS:
            <pre>
              <code class="language-css">
  .hero__copy--languages {
  
  }
              </code>
            </pre>

            </div>
            
            <div class="modifiers-right">
              Codigo en HTML(Modificador de un bloque):
                <pre>
                  <code class="language-markup">
<textarea readonly>
  <tag class ="block block--modifier">
  </tag>
</textarea>
                  </code>
                </pre>
                ó Modificador de un elemento:
                <pre>
                  <code class="language-markup">
<textarea readonly>
  <tag class ="block__element block__element--modifier">
  </tag>
</textarea>
                  </code>
                </pre>
              Ejemplo práctico: <br>
              HTML:
              <pre>
                <code class="language-markup">
<textarea readonly>
  <p class ="hero__copy hero__copy--languages">Contenido
  </p>
</textarea>
                </code>
              </pre>
   
          </div>
        </div>

         </p>
        </div>  
      </li>

      <li>
        <h2><a class="topics-title" href="javascript:void(0)">
        Orden de declaración 
        <p class="coming-soon">Próximamente</p>
      </a></h2>
        <div class= "topics-info">
          <p>
          Antes de pasar a conocer como se controla el orden al declarar en CSS, recordemos algo sobre la <strong>Herencia</strong>, la cual...
          <br> Ahora sí, veamos las 3 formas de como controlar el orden al declarar en CSS:
          <ol>
            <h3 class='topics-subtitle'>
              <li>Importancia</li>
            </h3>
            <ol>
              <li>Primero se aplican los estilos del navegador</li>
              <li>Luego se aplican nuestros archivos .css</li>
              <li>Finalmente se aplican los <code> !important</code></li>
            </ol>
            <p><br><strong>Notas: </strong>Recordar que el uso de !important es considerado una mala práctica, ya que puede romper nuestros estilos o llegar al punto de usarlo cada vez que no sepamos como funciona CSS </p>
            <h3 class='topics-subtitle'>
              <li>Especificidad</li>
            </h3>  
            <h3 class='topics-subtitle'>
              <li>Orden en las fuentes</li>
            </h3> 
            <p>Aquí se aplica el algoritmo de Cascada que tiene CSS, las declaraciones y/o reglas CSS que estén por debajo sobreescribirán o anularán a las que estén por arriba, en caso de conflicto. <br><br><strong>Notas: </strong> También tener en cuenta que al llamar en el archivo .html varios archivos .css, los de abajo también pueden reescribir a los de arriba.</p>
          </ol>
          </p>

        </div>  
      </li>

    </ol>
  </section>

  <section class="quiz-container">
    <p>Mide cuanto realmente aprendiste:</p>
    <a class="quiz" href="javascript:void(0)">Quiz Time!
      <p class="coming-soonq">Próximamente</p>
    </a>
  </section>  

  <footer>
    <p>
      Diseñado y codeado por <br> <strong> <a href="https://gsvidal.github.io" target="_blank"> Gonzalo Vidal </a> </strong> <br>
      Puedes encontrarme en estas plataformas:
      <div class="contact">
        <a href="https://gsvidal.github.io" target="_blank"><img src="https://i.postimg.cc/WbLs5F6b/MIYMC01.gif" alt="Portafolio de Proyectos Web" width="45px" height="45px"></a>
        <a href="https://github.com/gsvidal" target="_blank"><img src="https://i.postimg.cc/ncDt7Hyb/github.png" width="45px" height="45px" alt="Cuenta de GitHub: gsvidal"></a>
        <a href="https://www.linkedin.com/in/gsvidal/" target="_blank"><img src="https://i.postimg.cc/P5bs3SfS/linkedin.png" width="45px" height="45px" alt="Cuenta de Linkedin"></a>
        <a href="https://bio.torre.co/es/gsvidal" target="_blank"><img src="https://i.postimg.cc/VkPPWxwS/torre.png" width="45px" height="45px" alt="Cuenta de Torre"></a>
        <a href="https://www.instagram.com/gsvidal.web/" target="_blank"><img src="https://i.postimg.cc/PqtGB1PT/instagram.png" width="45px" height="45px" alt="Cuenta de Instagram: @gsvidal.web"></a>
      </div>
    </p>
  </footer>
  <!-- Hacer preguntas al final de cada artículo, para probar los conocimientos -->
</body>

<script src="./blog.js"></script>
<script src="./prism.js"></script>

</html>
