<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>5 Fundamentos Front-End</title>
  <link rel="stylesheet" href="./css/estilos.css">
  <link rel="stylesheet" href="./prism.css">
  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css2?family=PT+Serif:wght@400;700&family=Poppins:wght@200;300;400;700&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Courier+Prime&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Oxygen:wght@300;400;700&display=swap" rel="stylesheet">


</head>

<body>
  <div class="construction">
    <p> <strong>En construcción</strong><br>Inicio: 09/01/2021 <br> Estreno-aprox: 15/02/2021 <br> % Avance: </p>
    <div class="capacidad_barra">
      <div class="capacidad_barra_full">
      </div>
    </div>
  </div>
  <div class="header">
  <h1 class="blog-title">5 Fundamentos que todo desarrollador Front-End debe dominar
  </h1>
  <div class="blog-title__container">
  <p class="blog-title__description">
    Existen muchas y muchos desarrolladores con experiencia en esta industria, los cuales a lo largo de los años han logrado abrirse paso en medio de este mar de tecnologías, lenguajes y frameworks del mundo de la programación y lo han hecho bien hasta ahora, pero una parte de ellos(y no una insignificante) aún siente que mucho de esto funciona con una suerte de <i>Arte de Magia</i>, lo cual desde un punto de vista <i>holístico</i>, como el de la <strong>Ingeniería de Software</strong> no es lo ideal. 
  </p>
  <p class="blog-title__description">
    El saber las respuestas a preguntas tales como: <strong>"¿Como funciona el motor de JavaScript?"</strong>, <strong>"¿Como crear y en que puedo utilizar una Estructura de Datos?"</strong> o <strong>"¿Que ventajas puedo obtener por usar un lenguaje asíncrono?"</strong>, entre otras, puede abrir muchas puertas, incluso más allá de las que nos abrieron el saber programar o codear. 
  </p>  
  <p class="blog-title__description">
    En las siguientes líneas encontrarás información que quizás ya viste antes pero la dejaste de lado, por n motivos, pero creo que tú y yo sabemos que es momento de pasar al siguiente nivel. Te doy la bienvenida a mi Blog de los <i>Fundamentals de JavaScript, HTML y CSS.</i> 
  </p>
  </div>
  </div>
  
  <div class = "topics-container" id = "topics-container-JS">
    <ol class="numeracion-orden-principal">
      <li>
        <h2><a class="topics-title topics-title-ready" href="javascript:void(0)">
          Estructuras de Datos
        <p class="new">Nuevo!</p>
      </a></h2>

        <div class= "topics-info">
          <p>
            Según Wikipedia una <a class="enlaces-externos" href="https://es.wikipedia.org/wiki/Estructura_de_datos">estructura de datos</a> es una forma particular de organizar datos en una computadora para que puedan ser utilizados de manera eficiente. <br><br>
            También podemos definirlas como formas de organizar datos.
            Comprenden colecciones de valores, las relaciones entre ellos y las funciones y operaciones que se les puedan aplicar. <br><br>
            El uso "eficiente" que se le dará dependerá para que necesitaremos la estructura de datos que usaremos. Quizás necesitemos una estructura donde se requiere una rápida búsqueda de elementos, o una inserción eficiente, etc, todo dependerá de que aplicación estemos haciendo. <br><br>
            Aquí entra el tema de la <strong>complejidad.</strong> 
            <h3>La Complejidad</h3>
            Este término hace referencia a como se expresan las ventajas y desventajas que tiene cada estructura de datos al utilizarse en un problema en particular.
            La complejidad se puede expresar en 2 ejes: El <strong>espacio</strong> y el <strong>tiempo</strong>.
            <h4>El espacio</h4>
            La <strong>complejidad del espacio</strong> representa el consumo de memoria de una estructura de datos.
            <h4>El tiempo</h4>
            La <strong>complejidad del tiempo</strong> se necesita expresar para varias operaciones que puedes usar en estructuras de datos, tales como insertar(agregar), eliminar, buscar y/ o acceder elementos. <br>
            <figure>
              <img class="infografia" src="https://i.postimg.cc/1tBszKCD/GSVIDAL-WEB-6.png" alt="Infografía de tipos de estructuras de datos">
              <figcaption>Principales tipos de Estructuras de Datos</figcaption>
            </figure>

            
            <br>
            Podemos agrupar estas estructuras en 3 diferentes tipos: <br><br>
            <ol>
              <li class="elem-lista-numerada">
              Las estructuras del <i>tipo-Array</i>, como los <strong>Arrays</strong>, <strong>Stacks</strong> y <strong>Queues</strong> las cuales se diferencian principalmente en la forma de insertar y remover elementos de ellas.
              </li> 
              <li class="elem-lista-numerada">
                <strong>Linked Lists</strong>, <strong>Trees</strong> y <strong>Graphs</strong> son estructuras con <i>nodos</i>  que guardan referencias con otros nodos.
              </li> 
              <li class="elem-lista-numerada">
              Las <strong>Hash Tables</strong> dependen de <i>hash functions</i>  para localizar y guardar información.
              </li> 
            </ol>   
          
          Quieres ver el código js de todas estas estructuras de datos?. Puedes encontrarlo en GitHub en el repositorio <a class="enlaces-externos" href="" target="_blank">Data Structures-JS</a>

          <h3 class='topics-subtitle'>Arrays</h3>  
          Los Arrays(arreglos) son una colección de elementos, los cuales son emparejados con un key(índice), la forma más básica de esta estructura es el array lineal(array unidimensional).
          <br><br>
          Los arrays son de las estructuras más antiguas e importantes y de las más utilizadas en casi toda aplicación.
          <br><br>
          Creo que todos hemos utilizado un array en JavaScript, inizializándolo tan simple como:
          
          <pre>
            <code class="language-js">
var array1 = [1,3,4,5,7];
            </code>
          </pre>

          Pero ya que estamos en <i>Estructura de Datos</i>, vamos a crear una clase Array y a partir de ahí, crear métodos para buscar, agregar, remover valores del array. En pocas palabras veremos como crear métodos similares a .push(), .pop(), unshift(), .shift(), etc.
          <br>
          <pre>
            <code class="language-js">
 class MyArray { 
   constructor() {
     this.length = 0;
     this.data = {};
   }
 }              
            </code>
          </pre>
          
          Luego instanciaremos la clase MyArray:
          <br>
          <pre>

          <code class="language-js">
myArray = new MyArray();
          </code>
          </pre>
          
          *Podemos utilizar el Inspector de elementos para trabajar esto, lo que nos da el siguiente output:
          <pre>
            <code class="language-js">
              <output>
//MyArray {length: 0, data: {…}}
              </output>
            </code>
          </pre>
          Como vemos esa estructura está vacía, tiene un lenght de 0 y no contiene data. <br><br>
          Ahora creemos unos cuantos <strong>métodos</strong> para poder hacer operaciones sobre nuestro array. Los crearemos dentro de nuestra clase MyArray, previamente creada:<br>

          <pre>
            <code class="language-js">

 class MyArray {
   constructor() {
     this.length = 0;
     this.data = {};
   }
   //Nuestro método get devuelve el valor del índice index
   get(index) {
     return this.data[index];
   }
   //Nuestro método push añade al final un valor al array
   push(item) {
     this.data[this.length] = item;
     this.length++;
     return this.data;
   }
   //Nuestro método pop remueve el último elemento del array
   pop() {
     const lastItem = this.data[this.length - 1];
     delete this.data[this.length -1];
     this.length--;
   }
   //Nuestro método delete devuelve el elemento con índice index
   delete(index) {
     const item = this.data[index];
     this.shiftIndex(index);
     return item;
   }
   shiftIndex(index) {
     for(let i = index; i < this.length - 1; i++) {
       this.data[i] = this.data[i + 1];
     }
     delete this.data[this.length - 1];
     this.length--;
   }
   //Nuestro método unshiftItem añade un elemento(item) al inicio de nuestro array y devuelve la longitud
   unshiftItem(item) {
     this.length++;
     this.unshiftIndex();

     this.data[0] = item;
     
     return this.length;
   }
   unshiftIndex() {
     for(let i = this.length - 1; i > 0 ; i--) {
       this.data[i] = this.data[i-1];
     }
   }
   //Para nuestro método shiftItem vamos a remover el primer elemento de nuestro array, usaremos el método delete() creado anteriormente.
   shiftItem() {
     return this.delete(0);
   }
 }
              </code>
          </pre>

          <h3 class='topics-subtitle'>Stacks</h3> 

          Los <strong>stacks</strong> son también una colección de elementos apilados, con 3 operaciones, peek(), push() y pop(), la forma en que se añaden y remueven elementos es a través del ordenamiento LIFO(Last in, first out), es decir el último que entra es el primero que sale.
          Un ejemplo práctico y conocido de un stack es el call stack. 
          <figure>
            <img class="infografia infografia-chica" src="https://i.postimg.cc/sfWVc0PQ/GSVIDAL-WEB-14.jpg.jpg" alt="Imagen de un stack">
            <figcaption>Diagrama de un stack</figcaption>
          </figure>
          Ahora pasemos a lo interesante, crearemos un stack usando clases como en el caso del array. <br>
          Pero antes de eso expliquemos el concepto de <i>nodos</i>, que utilizaremos a lo largo del tema de estructura de datos, y si bien mencionamos que los Linked Lists, Trees y Graphs son estructuras basadas en nodos, también podemos tratar a cada elemento del stack(y más adelante al queue), como un nodo que tiene un valor(value) y que tiene una referencia a través de un puntero al siguiente elemento(en el caso del stack el siguiente elemento es el próximo en entrar).
          
          <pre>
            <code class="language-js">
 //Creamos una clase Node(nodo) para no código en los métodos
 class Node {
   constructor(value) {
     this.value = value;
     this.next = null;
   }
 }

class Stack {
  constructor() {
    this.top = null;
    this.bottom = null;
    this.length = 0;
  }
  //Nuestro método peek nos devuelve el elemento el top
  peek() {
    return this.top;
  }
  //Nuestro método push agrega un elemento al (top) del stack y nos devuelve el stack
  push(value) {
    const newNode = new Node(value);
    if(this.length === 0) {
      this.top = newNode;
      this.bottom = this.top;
    } else {
      const holdingPointer = newNode;
      this.top.next = holdingPointer;
      this.top = holdingPointer;
    }
    this.length++;

    return this;
  }
  //Nuestro método pop remueve el elemento top nos devuelve el stack
  pop() {
    var penultimo = myStack.bottom;
    for(let i = 0; i < this.length-2; i++) {
      penultimo = penultimo.next;
    }

    this.top = penultimo;
    this.top.next = null;
    this.length--;

    return this;
  }
}
//Instanciamos la clase Stack
const myStack = new Stack();
            </code>
          </pre>

          <h3 class='topics-subtitle'>Queues</h3> 

          Los <strong>queues</strong> son <i>colas</i>, sus operaciones principales son agregar al final de la cola(enqueue) y remover el primer elemento de la cola (dequeue), usa el protocolo FIFO (First in First Out), lo que significa que el primero que entra a la cola, es el primero que sale.
          <figure>
            <img class="infografia infografia-chica" src="https://i.postimg.cc/SxkNj7MX/GSVIDAL-WEB-15.jpg" alt="Imagen de un queue">
            <figcaption>Diagrama de un Queue</figcaption>
          </figure>
          Veamos el código:
          <pre>
            <code class="language-js">
class Node {
  constructor(value) {
    this.value = value;
    this.next = null;
  }
}

class Queue {
  constructor() {
    this.first = null;
    this.last = null;
    this.length = 0;
  }
  //Nuestro método peek nos devuelve el elemento en el top
  peek() {
    return this.first;
  }
  //Con nuestro método enqueue agregaremos un elemento al final de la cola
  enqueue(value) {
    const newNode = new Node(value);
    if(this.length === 0) {
      this.first = newNode;
      this.last = newNode;
    } else {
      this.last.next = newNode;
      this.last = newNode;
    }
    this.length++;

    return this;
  }
  //Con nuestro método dequeue removeremos el primer elemento de la cola
  dequeue() {
    if(this.length !== 0) {
    const second = myQueue.first.next;
    this.first = second;
    this.length--;

    return this;
    } else {
      console.log("Queue is empty, you cannot dequeue!")
    }
  }
  
}
//Instanciamos la clase Queue
const myQueue = new Queue();

            </code>
          </pre>

          <h3 class='topics-subtitle'>Hash Tables</h3> 

          Un <strong>Hash Table</strong> es una estructura de datos usada para implementar un array asociativo, donde se puede emparejar <i>keys</i> y <i>values</i>. Es similar a un objeto de JavaScript, con la diferencia que la hash table tiene un <strong>Hash Function</strong> que determina en que parte de la memoria se ubicarán estos datos. Esta Hash Function recibe como argumento al key y retorna la dirección(address) de la locación en donde estará esta información. Pueden existir colisiones, lo que significa que puede haber dos keys diferentes para un mismo address, pero con el método set que veremos más adelante al enviar como parámetro al key, nos devolverá su value.
          <figure>
            <img class="infografia" src="https://i.postimg.cc/k4K8ygYB/GSVIDAL-WEB-13.jpg" alt="Imagen de un hash table">
            <figcaption>Diagrama de Hash Table</figcaption>
          </figure>

          <pre>
            <code class="language-js">
 class HashTable {
   constructor(size) {
     this.data = new Array(size);
   }
   //Lo siguiente es un Hash que fue creado arbitrariamenteexisten muchos Hash Functions GitHub
   hashMethod(key) {
     let hash = 0;
     for (let i = 0; i < key.length; i+) {
       hash = (hash + key.charCodeAt(i * i) % this.data.length;
     }
     return hash;
   }
   //El metodo set nos insertar un valor con key y value(puede haber colisiones)
   set(key, value) {
     const address = this.(key);
     if (!this.data[address]) {
       this.data[address] = [];
     }
     this.data[address].push([keyvalue]);
     return this.data;
   }
   //El metodo get nos devuelve el valor que le corresponde al key que enviemos como parámetro, en caso no exista el key nos devolverá undefined
   get(key) {
     const address = this.(key);
     const currentBucket = this.[address];
     if (currentBucket) {
       for (let i = 0; i  currentBucket.length; i++) {
         if (currentBucket[i][0] === key) {
           return currentBucket[i][1];
         }
       }
     }
     return undefined;
   }
 }      
 //Instanciamos el HashTable con 50 espacios libres
 const myHashTable = new HashTable(50);  

            </code>
          </pre>
            

          <h3 class='topics-subtitle'>Linked Lists</h3> 

          Los <strong>Linked Lists</strong> almacenan data en forma secuencial, pero en lugar de mantener índices, mantienen <i>pointers(punteros)</i> a otros elementos.
          El primer nodo es llamado <strong>head</strong> y el último nodo <strong>tail</strong>. <br><br>
          Existen dos tipos de linked list:
          <ol>
            <li>
              <strong>Singly Linked List:</strong>  <br>
              Cada nodo tiene solo un puntero hacia el siguiente nodo <i>(next)</i>.
            </li>
            <li>
              <strong>Doubly Linked List:</strong>  <br>
              Aquí aparte del <i>next</i>, cada nodo tiene también un puntero hacia el nodo previo(prev).
            </li>
          </ol>
          <br>
          <figure class="infografias-container">
           <div>
            <img class="infografias" src="https://i.postimg.cc/GhBvqR7P/GSVIDAL-WEB-16.jpg" alt="Imagen de Singly Linked List">
            <figcaption>Diagrama de un Singly Linked List</figcaption>
           </div>
           <div>
            <img class="infografias" src="https://i.postimg.cc/R0TtNZhm/GSVIDAL-WEB-17.jpg" alt="Imagen de Doubly Linked List">
            <figcaption>Diagrama de un Doubly Linked List</figcaption>
           </div>
          </figure>
          Démosle un vistazo al código: <br>
          <strong>Singly Linked List:</strong>
          <pre>
            <code class="language-js">
 //Creamos una clase Node(nodo) para no código en los métodos
 class Node {
   constructor(value) {
     this.value = value;
     this.next = null;
   }
 }
 
 class MySinglyLinkedList {
   constructor(value) {
     this.head = {
       value: value,
       next: null
     }
     this.tail = this.head;
     this.length = 1;
   }
   //Nuestro método append agregará un elemento tail del Singly Linked List
   append(value) {
     const newNode = new Node(value);
     this.tail.next = newNode;
     this.tail = newNode;
     this.length++;
 
     return this;
   }
   //Nuestro método prepend agregará un elemento el head del Singly Linked List
   prepend(value) {
     const newNode = new Node(value);
     newNode.next = this.head;
     this.head = newNode;
 
     this.length++;
   }
   //Nuestro método insert insertará un elemento el nodode índice index en el Singly Linked List
   insert(index, value) {
     if(index >= this.length) {
       console.log("No hay suficientes elementosserá enviado al final");
       return this.append(value);
     }
 
     const newNode = new Node(value); 
     const firstPointer = this.getTheIndex(index 1);
     //Se crea una const holdingPointer que para no perder el puntero next firstPointer.
     const holdingPointer = firstPointer.next;
     firstPointer.next = newNode;
     newNode.next = holdingPointer;
 
     this.length++;
 
     return this;
   }
 
   getTheIndex(index) {
     let currentNode = this.head;
 
     for(let counter = 0; counter < this.lengthcounter++) {
       if(counter !== index) {
         currentNode = currentNode.next;
       } else{
         return currentNode;
       }
     }
   }
 }
 //Instanciando MySinglyLinkedList:
 let myLinkedList = new MySinglyLinkedList(1;              
            </code>
          </pre>

          <strong>Doubly Linked List:</strong>
          <pre>
            <code class="language-js">
//Como podremos ver el código para la de un doubly solo se diferencia por ser cuantas líneas más larga:

//Creamos una clase Node(nodo) para reescribir código en los métodos
class Node {
  constructor(value) {
    this.value = value;
    this.next = null;
    this.prev = null;
  }
}
 
class MyDoublyLinkedList {
  constructor(value) {
    this.head = {
      value: value,
      next: null,
      // Doubly: se añade la siguiente linea
      prev: null,
    };
    this.tail = this.head;
 
    this.length = 1;
  }
  append(value) {
    const newNode = new Node(value);
    newNode.prev = this.tail;
    this.tail.next = newNode;
    this.tail = newNode;
    this.length++;
 
    return this;
  }
  prepend(value) {
    const newNode = new Node(value);
    // Doubly: se añade la siguiente linea
    this.head.prev = newNode;
    
    newNode.next = this.head;
    this.head = newNode;
 
    this.length++;
  }
  insert(index, value) {
    if(index >= this.length) {
      console.log("No hay suficientes elementos, será enviado al final");
      return this.append(value);
    }
 
    const newNode = new Node(value);
    let firstPointer = this.getTheIndex(- 1);
    let secondPointer = this.getTheIndex(index;
    let holdingPointer = firstPointer.next;
    firstPointer.next = newNode;
    newNode.next = holdingPointer;
    // Doubly: se añaden las siguientes líneas
    holdingPointer.prev = newNode;
    firstPointer = newNode.prev;
    holdingPointer = secondPointer;
 
    this.length++;
 
    return this;
 
  }
 
  getTheIndex(index) {
    
    let currentNode = this.head;
 
    for(let counter = 0; counter < thislength; counter++) {
      if(counter !== index) {
        currentNode = currentNode.next;
      } else{
        return currentNode;
      }
    }
  }
  
}
//Instanciado MyDoublyLinkedList:
let myDoublyLinkedList = new (1);              
            </code>
          </pre>

          <h3 class='topics-subtitle'>Trees</h3> 

          Los <strong>Trees</strong> son  
          <figure>
            <img class="infografia infografia-chica" src="https://i.postimg.cc/yNrjP8RV/GSVIDAL-WEB-8.jpg" alt="Imagen de un stack">
            <figcaption>Diagrama de un Tree</figcaption>
          </figure>

          <h3 class='topics-subtitle'>Graphs</h3> 

          Los <strong>Graphs</strong> son  
          <figure>
            <img class="infografia infografia-chica" src="https://i.postimg.cc/yNrjP8RV/GSVIDAL-WEB-8.jpg" alt="Imagen de un stack">
            <figcaption>Diagrama de un Graph</figcaption>
          </figure>

          


          
          </p>
        </div>  
      </li>

      <li>
        <h2><a class="topics-title" href="javascript:void(0)">
          Motores de JavaScript
        <p class="coming-soon">Próximamente</p>
      </a></h2>
        <div class= "topics-info">
          <p>
            Como desarrolladores web, es bueno conocer los fundamentos del lenguaje Javascript y de su motor, este último con el fin de comprender como a partir de un lenguaje que los humanos podemos entender, se llega a convertir en algo que las maquinas pueden entender.
          <h3 class='topics-subtitle'>Diferentes Motores de Javascript</h3>  
          Cada navegador tiene su propio motor de javascript, entre los más conocidos tenemos a:
          </p>
        </div>  
      </li>

      <li>
        <h2><a class="topics-title" href="javascript:void(0)">
          Objetos
        <p class="coming-soon">Próximamente</p>
      </a></h2>
        <div class= "topics-info">
          <p>
          Los objetos son...
          </p>
        </div>  
      </li>

      <li>
        <h2><a class="topics-title" href="javascript:void(0)">
          Métodos en JavaScript
        <p class="coming-soon">Próximamente</p>
      </a></h2>
        <div class= "topics-info">
          <p>
          Los métodos  son...
          </p>
        </div>  
      </li>

      <li>
        <h2><a class="topics-title" href="javascript:void(0)">
          Asincronismo
        <p class="coming-soon">Próximamente</p>
      </a></h2>
        <div class= "topics-info">
          <p>
          El Asincronismo es...
          </p>
        </div>  
      </li>

    </ol>
  </div>

  <div class = "topics-container" id = "topics-container-HTML">
    <ol class="numeracion-orden-principal">
      <li>
        <h2><a class="topics-title" href="javascript:void(0)">
          Anatomía de una etiqueta HTML
        <p class="coming-soon">Próximamente</p>
      </a></h2>
        <div class= "topics-info">
          <p>
          Conocer la anatomía de las etiquetas HTML te dará muchas ventajas al ...
          <img class='' src='' width='30%'>
          </img>
          </p>
        </div>  
      </li>

      <li>
        <h2><a class="topics-title" href="javascript:void(0)">
          Etiquetas
        <p class="coming-soon">Próximamente</p>
      </a></h2>
        <div class= "topics-info">
          <p>
          Entre las etiquetas HTML más conocidas tenemos a:
          </p>
        </div>  
      </li>

    </ol>
  </div>

  <div class = "topics-container" id = "topics-container-CSS">
    <ol class="numeracion-orden-principal">
      <li>
        <h2><a class="topics-title" href="javascript:void(0)">
          Anatomía de una Regla CSS
        <p class="coming-soon">Próximamente</p>
      </a></h2>
        <div class= "topics-info">
          <p>
          Las Reglas, así como las etiquetas en HTML, son los ladrillos sobre los que se construyen las aplicaciones, paginas y sitios webs.
          <img class='' src='' width='30%'>
          </img>
          </p>
        </div>  
      </li>

      <li>
        <h2><a class="topics-title" href="javascript:void(0)">
          Nomenclatura en CSS
        <p class="coming-soon">Próximamente</p>
      </a></h2>
        <div class= "topics-info">
          <p>
          Existen varias metodologías o convenciones para nombrar a las classes en CSS.
          Fuentes:
          https://iknowdavehouse.medium.com/bem-for-everyone-else-89ccc8ad66f2
          </p>
        </div>  
      </li>

      <li>
        <h2><a class="topics-title topics-title-ready" href="javascript:void(0)">
        Orden de declaración 
        <p class="coming-soon">Próximamente</p>
      </a></h2>
        <div class= "topics-info">
          <p>
          Antes de pasar a conocer como se controla el orden al declarar en CSS, recordemos algo sobre la <strong>Herencia</strong>, la cual...
          <br> Ahora sí, veamos las 3 formas de como controlar el orden al declarar en CSS:
          <ol>
            <h3 class='topics-subtitle'>
              <li>Importancia</li>
            </h3>
            <ol>
              <li>Primero se aplican los estilos del navegador</li>
              <li>Luego se aplican nuestros archivos .css</li>
              <li>Finalmente se aplican los <code> !important</code></li>
            </ol>
            <p><br><strong>Notas: </strong>Recordar que el uso de !important es considerado una mala práctica, ya que puede romper nuestros estilos o llegar al punto de usarlo cada vez que no sepamos como funciona CSS </p>
            <h3 class='topics-subtitle'>
              <li>Especificidad</li>
            </h3>  
            <h3 class='topics-subtitle'>
              <li>Orden en las fuentes</li>
            </h3> 
            <p>Aquí se aplica el algoritmo de Cascada que tiene CSS, las declaraciones y/o reglas CSS que estén por debajo sobreescribirán o anularán a las que estén por arriba, en caso de conflicto. <br><br><strong>Notas: </strong> También tener en cuenta que al llamar en el archivo .html varios archivos .css, los de abajo también pueden reescribir a los de arriba.</p>
          </ol>
          </p>

        </div>  
      </li>

    </ol>
  </div>

  <div class="quiz-container">
    <p>Mide cuanto realmente aprendiste:</p>
    <a class="quiz" href="javascript:void(0)">Quiz Time!
      <p class="coming-soonq">Próximamente</p>
    </a>
  </div>  

  <footer>
    <p>
      Diseñado y codeado por <br> <strong> <a href="https://gsvidal.github.io" target="_blank"> Gonzalo Vidal </a> </strong> <br>
      Puedes encontrarme en estas plataformas:
      <div class="contact">
        <a href="https://gsvidal.github.io" target="_blank"><img src="https://i.postimg.cc/WbLs5F6b/MIYMC01.gif" alt="Portafolio de Proyectos Web" width="45px" height="45px"></a>
        <a href="https://github.com/gsvidal" target="_blank"><img src="https://i.postimg.cc/ncDt7Hyb/github.png" width="45px" height="45px" alt="Cuenta de GitHub: gsvidal"></a>
        <a href="https://www.linkedin.com/in/gonzalosebastianvidal/" target="_blank"><img src="https://i.postimg.cc/P5bs3SfS/linkedin.png" width="45px" height="45px" alt="Cuenta de Linkedin"></a>
        <a href="https://bio.torre.co/es/gsvidal" target="_blank"><img src="https://i.postimg.cc/VkPPWxwS/torre.png" width="45px" height="45px" alt="Cuenta de Torre"></a>
        <a href="https://www.instagram.com/gsvidal.web/" target="_blank"><img src="https://i.postimg.cc/PqtGB1PT/instagram.png" width="45px" height="45px" alt="Cuenta de Instagram: @gsvidal.web"></a>
      </div>
    </p>
  </footer>
  <!-- Hacer preguntas al final de cada artículo, para probar los conocimientos -->
</body>

<script src="./blog.js"></script>
<script src="./prism.js"></script>

</html>
